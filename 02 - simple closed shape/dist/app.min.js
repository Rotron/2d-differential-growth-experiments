"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw a.code = "MODULE_NOT_FOUND", a;
        }

        var p = n[i] = {
          exports: {}
        };
        e[i][0].call(p.exports, function (r) {
          var n = e[i][1][r];
          return o(n || r);
        }, p, p.exports, r, e, n, t);
      }

      return n[i].exports;
    }

    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
      o(t[i]);
    }

    return o;
  }

  return r;
})()({
  1: [function (require, module, exports) {
    module.exports = {
      MinDistance: 20,
      // injection, attraction
      MaxDistance: 30,
      // split
      RepulsionRadius: 20,
      MaxVelocity: .1,
      Acceleration: .1,
      AttractionForce: .001,
      RepulsionForce: 500,
      AlignmentForce: .001,
      ScreenPadding: 20,
      MaxNodes: 3000,
      NodeInjectionInterval: 100,
      DrawNodes: false,
      TraceMode: false
    };
  }, {}],
  2: [function (require, module, exports) {
    var Node = require('../../core/Node'),
        Path = require('../../core/Path'),
        World = require('../../core/World'),
        Settings = require('./Settings');

    var world;
    var TRIANGLE = 0,
        SQUARE = 1,
        CIRCLE = 2;
    var currentPathType = CIRCLE;
    /*
    =============================================================================
      Main sketch
    =============================================================================
    */

    var sketch = function sketch(p5) {
      // Setup -------------------------------------------------------------
      p5.setup = function () {
        p5.createCanvas(window.innerWidth, window.innerHeight); // p5.frameRate(1);
        // p5.noLoop();
        // Set up and start the simulation

        world = new World(p5, undefined, Settings);
        restartWorldWith(currentPathType);
      }; // Draw ---------------------------------------------------------------


      p5.draw = function () {
        world.iterate();
        world.draw();
      }; // Create any generalized equilateral polygon -------------------------


      function createPolygon(nodeCount, radius) {
        var rotation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var nodes = [];

        for (var i = 0; i < nodeCount; i++) {
          var angle = 2 * Math.PI * i / nodeCount + p5.radians(rotation);
          var x = Math.floor(radius * Math.cos(angle));
          var y = Math.floor(radius * Math.sin(angle));
          nodes.push(new Node(p5, window.innerWidth / 2 + x, window.innerHeight / 2 + y, false, Settings));
        }

        return nodes;
      } // Create nodes in a circle -------------------------------------------
      // Remember a circle on a computer is just a polygon with many sides!


      function createCircle() {
        return createPolygon(11, 100);
      } // Create three nodes to form an equilateral triangle -----------------


      function createTriangle() {
        return createPolygon(3, 100, 30);
      } // Create four nodes to form a square ---------------------------------


      function createSquare() {
        return createPolygon(4, 100, 45);
      } // Restart the simulation with a selected path type -------------------


      function restartWorldWith(pathType) {
        currentPathType = pathType;
        world.clearPaths();

        switch (pathType) {
          case TRIANGLE:
            world.addPath(new Path(p5, createTriangle(), true, Settings));
            break;

          case SQUARE:
            world.addPath(new Path(p5, createSquare(), true, Settings));
            break;

          case CIRCLE:
            world.addPath(new Path(p5, createCircle(), true, Settings));
            break;
        } // Draw the first frame, then pause


        p5.background(255);
        world.iterate();
        world.draw();
        world.pause(); // Restart simulation after 1s

        setTimeout(function () {
          world.unpause();
        }, 1000);
      }
      /*
      =============================================================================
        Key handler
      =============================================================================
      */


      p5.keyReleased = function () {
        switch (p5.key) {
          // Restart simulation with a triangle path
          case '1':
            restartWorldWith(TRIANGLE);
            break;
          // Restart simulation with a square path

          case '2':
            restartWorldWith(SQUARE);
            break;
          // Restart simulation with a circle path

          case '3':
            restartWorldWith(CIRCLE);
            break;
          // Pause/unpause the world with 'p'

          case 'p':
            world.paused = !world.paused;
            break;
          // Toggle trace mode with 't'

          case 't':
            world.traceMode = !world.traceMode;
            restartWorldWith(currentPathType);
            break;
          // Toggle drawing of nodes with 'n'

          case 'n':
            world.drawNodes = !world.drawNodes;
            break;
          // Reset simulation with current parameters with 'r'

          case 'r':
            restartWorldWith(currentPathType);
            break;
          // Toggle debug mode with 'd'
          // Export SVG with 's'
        }
      };
    }; // Launch the sketch using p5js in instantiated mode


    new p5(sketch);
  }, {
    "../../core/Node": 4,
    "../../core/Path": 5,
    "../../core/World": 6,
    "./Settings": 1
  }],
  3: [function (require, module, exports) {
    arguments[4][1][0].apply(exports, arguments);
  }, {
    "dup": 1
  }],
  4: [function (require, module, exports) {
    var Vec2 = require('./node_modules/vec2'),
        Defaults = require('./Defaults');
    /*
    =============================================================================
      Node class
    
      DESCRIPTION:
      A Node is a single point on the canvas whose only job is to manage
      it's position and movement towards new position. 
    =============================================================================
    */


    var Node =
    /*#__PURE__*/
    function (_Vec) {
      _inherits(Node, _Vec);

      function Node(p5, x, y) {
        var _this;

        var isFixed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var settings = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Defaults;

        _classCallCheck(this, Node);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Node).call(this, x, y));
        _this.p5 = p5;
        _this.isFixed = isFixed;
        _this.settings = settings;
        _this.velocity = 0;
        _this.nextPosition = new Vec2(x, y);
        return _this;
      } // TODO: Add acceleration


      _createClass(Node, [{
        key: "iterate",
        value: function iterate() {
          this.x = this.p5.lerp(this.x, this.nextPosition.x, this.settings.MaxVelocity);
          this.y = this.p5.lerp(this.y, this.nextPosition.y, this.settings.MaxVelocity); // this.lerp(this.nextPosition, this.settings.MaxVelocity);
          // this.position = this.nextPosition;
          // if(this.velocity < Defaults.MaxVelocity) {
          //   this.velocity += Defaults.Acceleration;
          // }
        }
      }, {
        key: "draw",
        value: function draw() {
          if (this.isFixed) {
            this.p5.fill(255, 0, 0);
          } else {
            this.p5.fill(0);
          }

          if (this.isFixed) {
            this.p5.ellipse(this.x, this.y, 10);
          } else {
            this.p5.ellipse(this.x, this.y, 5);
          }
        }
      }]);

      return Node;
    }(Vec2);

    module.exports = Node;
  }, {
    "./Defaults": 3,
    "./node_modules/vec2": 11
  }],
  5: [function (require, module, exports) {
    var rbush = require('./node_modules/rbush'),
        knn = require('./node_modules/rbush-knn'),
        Vec2 = require('./node_modules/vec2'),
        Node = require('./Node'),
        Defaults = require('./Defaults');
    /*
    =============================================================================
      Path class
    
      DESCRIPTION:
      A Path manages a set of Nodes in a continuous, ordered
      data structure (an Array). 
    =============================================================================
    */


    var Path =
    /*#__PURE__*/
    function () {
      function Path(p5, nodes) {
        var isClosed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Defaults;

        _classCallCheck(this, Path);

        this.p5 = p5;
        this.nodes = nodes;
        this.isClosed = isClosed;
        this.settings = settings;
        this.tree = rbush();
        this.buildTree();
        this.lastNodeInjectTime = 0;
      } //------------------------------------------------------------------
      //  Iterate
      //  =======
      //  Run a single 'tick' of the simulation 
      //-----------------------------------------------------------------


      _createClass(Path, [{
        key: "iterate",
        value: function iterate() {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.nodes.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2),
                  index = _step$value[0],
                  node = _step$value[1];

              // Apply Brownian motion to realistically 'jiggle' nodes
              // this.applyBrownianMotion(index);
              // Move towards neighbors (attraction), if there is space to move
              this.applyAttraction(index); // Move away from any nodes that are too close (repulsion)

              this.applyRepulsion(index); // Align with neighbors

              this.applyAlignment(index); // Move towards next position with velocity and acceleration

              node.iterate();
            } // Split any edges that have become too long

          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this.splitEdges(); // Inject a new node to introduce asymmetry every so often

          if (this.p5.millis() - this.lastNodeInjectTime >= this.settings.NodeInjectionInterval && this.nodes.length < this.settings.MaxNodes) {
            // this.injectNode();
            this.lastNodeInjectTime = this.p5.millis();
          } // Rebuild the spatial index


          this.buildTree();
        } //---------------------------------------------------------------------
        //  Attraction
        //  ==========
        //  Move the referenced node closer to it's connected neighbor nodes
        //---------------------------------------------------------------------

      }, {
        key: "applyAttraction",
        value: function applyAttraction(index) {
          var distance;
          var connectedNodes = this.getConnectedNodes(index); // Move towards next node, if there is one

          if (connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && !this.nodes[index].isFixed) {
            distance = this.nodes[index].distance(connectedNodes.nextNode);

            if (distance > this.settings.MinDistance) {
              this.nodes[index].nextPosition = this.nodes[index].lerp(connectedNodes.nextNode, this.settings.AttractionForce, true);
            }
          } // Move towards previous node, if there is one


          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && !this.nodes[index].isFixed) {
            distance = this.nodes[index].distance(connectedNodes.previousNode);

            if (distance > this.settings.MinDistance) {
              this.nodes[index].nextPosition = this.nodes[index].lerp(connectedNodes.previousNode, this.settings.AttractionForce, true);
            }
          }
        } //------------------------------------------------------------------------
        //  Repulsion
        //  =========
        //  Move the referenced node away from all nearby nodes within a radius
        //------------------------------------------------------------------------

      }, {
        key: "applyRepulsion",
        value: function applyRepulsion(index) {
          // Perform knn search to find all neighbors within certain radius
          var neighbors = knn(this.tree, this.nodes[index].x, this.nodes[index].y); // Move this node away from all nearby neighbors
          // TODO: Make this proportional to distance?

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = neighbors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var node = _step2.value;
              this.nodes[index].nextPosition = this.nodes[index].lerp(node, -this.settings.RepulsionForce, true);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        } //-------------------------------------------------------------
        //  Alignment
        //  =========
        //  Move the referenced node closer to the midpoint of it's
        //  neighbor connected nodes to minimize curvature
        //-------------------------------------------------------------

      }, {
        key: "applyAlignment",
        value: function applyAlignment(index) {
          var connectedNodes = this.getConnectedNodes(index);

          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && !this.nodes[index].isFixed) {
            // Find the midpoint between the neighbors of this node
            var midpoint = new Vec2((connectedNodes.previousNode.x + connectedNodes.nextNode.x) / 2, (connectedNodes.previousNode.y + connectedNodes.nextNode.y) / 2); // Move this point towards this midpoint

            this.nodes[index].nextPosition = midpoint.lerp(this.nodes[index].nextPosition, this.settings.AlignmentForce);
          }
        } //--------------------------------------------------------------
        //  Split edges
        //  ===========
        //  Search for long edges, then inject a new node when found
        //
        //  TODO:
        //  - Collect new nodes and inject all at once, not one at a time, to prevent asymmetric recursive splitting
        //--------------------------------------------------------------

      }, {
        key: "splitEdges",
        value: function splitEdges() {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this.nodes.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _step3$value = _slicedToArray(_step3.value, 2),
                  index = _step3$value[0],
                  node = _step3$value[1];

              var connectedNodes = this.getConnectedNodes(index);

              if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && node.distance(connectedNodes.previousNode) >= this.settings.MaxDistance && this.nodes.length < this.settings.MaxNodes) {
                var midpointNode = new Node(this.p5, (node.x + connectedNodes.previousNode.x) / 2, (node.y + connectedNodes.previousNode.y) / 2, false, this.settings);

                if (index == 0) {
                  this.nodes.splice(this.nodes.length, 0, midpointNode);
                } else {
                  this.nodes.splice(index, 0, midpointNode);
                }
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        } //---------------------------------------------------
        //  Inject a node
        //  =============
        //  Create a new node between two existing nodes
        //---------------------------------------------------

      }, {
        key: "injectNode",
        value: function injectNode() {
          // Choose two connected nodes at random
          var index = parseInt(this.p5.random(this.nodes.length));
          var connectedNodes = this.getConnectedNodes(index);

          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && connectedNodes.previousNode.distance(connectedNodes.nextNode) > this.settings.MinDistance) {
            // Create a new node in the middle
            var midpointNode = new Node(this.p5, (connectedNodes.previousNode.x + this.nodes[index].x) / 2, (connectedNodes.previousNode.y + this.nodes[index].y) / 2, false, this.settings); // Splice new node into array

            this.nodes.splice(index, 0, midpointNode);
          }
        } //------------------------------------------------------------
        //  Get connected nodes
        //  ===================
        //  For a given node, find and return the nodes that come 
        //  immediately before and after it.
        //------------------------------------------------------------

      }, {
        key: "getConnectedNodes",
        value: function getConnectedNodes(index) {
          var previousNode, nextNode; // Find previous node, if there is one

          if (index == 0 && this.isClosed) {
            previousNode = this.nodes[this.nodes.length - 1];
          } else if (index >= 1) {
            previousNode = this.nodes[index - 1];
          } // Find next node, if there is one


          if (index == this.nodes.length - 1 && this.isClosed) {
            nextNode = this.nodes[0];
          } else if (index <= this.nodes.length - 1) {
            nextNode = this.nodes[index + 1];
          }

          return {
            previousNode: previousNode,
            nextNode: nextNode
          };
        } // Rebuild the spatial index

      }, {
        key: "buildTree",
        value: function buildTree() {
          this.tree.clear();
          this.tree.load(this.nodes);
        } //--------------------------------------------
        //  Draw
        //  ====
        //  Draw all nodes and edges to the canvas
        //--------------------------------------------

      }, {
        key: "draw",
        value: function draw(drawNodes) {
          // Draw edges between nodes
          for (var i = 0; i < this.nodes.length - 1; i++) {
            this.p5.line(this.nodes[i].x, this.nodes[i].y, this.nodes[i + 1].x, this.nodes[i + 1].y);
          } // Draw a line between last and first node to close the path, if needed


          if (this.isClosed) {
            this.p5.line(this.nodes[this.nodes.length - 1].x, this.nodes[this.nodes.length - 1].y, this.nodes[0].x, this.nodes[0].y);
          } // Draw all nodes


          if (drawNodes) {
            this.p5.fill(0);
            this.p5.noStroke();
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = undefined;

            try {
              for (var _iterator4 = this.nodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                var node = _step4.value;
                node.draw();
              }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }
          }
        }
      }]);

      return Path;
    }();

    module.exports = Path;
  }, {
    "./Defaults": 3,
    "./Node": 4,
    "./node_modules/rbush": 9,
    "./node_modules/rbush-knn": 8,
    "./node_modules/vec2": 11
  }],
  6: [function (require, module, exports) {
    var Defaults = require('./Defaults');
    /*
    =============================================================================
      World class
    
      DESCRIPTION:
      A World manages a set of Paths and provides some global control
      mechanisms, such as pausing the simulation.
    =============================================================================
    */


    var World =
    /*#__PURE__*/
    function () {
      function World(p5) {
        var paths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Defaults;

        _classCallCheck(this, World);

        this.p5 = p5;
        this.paths = paths;
        this.paused = false;
        this.settings = settings;
      } // Run a single tick for all paths -----------------


      _createClass(World, [{
        key: "iterate",
        value: function iterate() {
          if (this.paths != undefined && this.paths instanceof Array && this.paths.length > 0 && !this.paused) {
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = this.paths[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var path = _step5.value;
                path.iterate();
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                  _iterator5.return();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }
          }
        } // Draw all paths ----------------------------------

      }, {
        key: "draw",
        value: function draw() {
          if (!this.paused) {
            if (!this.traceMode) {
              this.p5.background(255);
            }

            if (this.paths != undefined && this.paths instanceof Array && this.paths.length > 0) {
              if (this.traceMode) {
                this.p5.stroke(0, 0, 0, 2);
              } else {
                this.p5.stroke(0, 0, 0, 255);
              }

              var _iteratorNormalCompletion6 = true;
              var _didIteratorError6 = false;
              var _iteratorError6 = undefined;

              try {
                for (var _iterator6 = this.paths[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                  var path = _step6.value;
                  path.draw(this.drawNodes);
                }
              } catch (err) {
                _didIteratorError6 = true;
                _iteratorError6 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                    _iterator6.return();
                  }
                } finally {
                  if (_didIteratorError6) {
                    throw _iteratorError6;
                  }
                }
              }
            }
          }
        } // Add a new path to the world ---------------------

      }, {
        key: "addPath",
        value: function addPath(path) {
          this.paths.push(path);
        } // Remove all paths from the world -----------------

      }, {
        key: "clearPaths",
        value: function clearPaths() {
          this.paths = [];
        } // Pause the simulation ----------------------------

      }, {
        key: "pause",
        value: function pause() {
          this.paused = true;
        } // Unpause the simulation --------------------------

      }, {
        key: "unpause",
        value: function unpause() {
          this.paused = false;
        }
      }]);

      return World;
    }();

    module.exports = World;
  }, {
    "./Defaults": 3
  }],
  7: [function (require, module, exports) {
    (function (global, factory) {
      _typeof(exports) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.quickselect = factory();
    })(this, function () {
      'use strict';

      function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
      }

      function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) swap(arr, left, right);

          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;

            while (compare(arr[i], t) < 0) {
              i++;
            }

            while (compare(arr[j], t) > 0) {
              j--;
            }
          }

          if (compare(arr[left], t) === 0) swap(arr, left, j);else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
        }
      }

      function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }

      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }

      return quickselect;
    });
  }, {}],
  8: [function (require, module, exports) {
    'use strict';

    var Queue = require('tinyqueue');

    module.exports = knn;
    module.exports.default = knn;

    function knn(tree, x, y, n, predicate, maxDistance) {
      var node = tree.data,
          result = [],
          toBBox = tree.toBBox,
          i,
          child,
          dist,
          candidate;
      var queue = new Queue(null, compareDist);

      while (node) {
        for (i = 0; i < node.children.length; i++) {
          child = node.children[i];
          dist = boxDist(x, y, node.leaf ? toBBox(child) : child);

          if (!maxDistance || dist <= maxDistance) {
            queue.push({
              node: child,
              isItem: node.leaf,
              dist: dist
            });
          }
        }

        while (queue.length && queue.peek().isItem) {
          candidate = queue.pop().node;
          if (!predicate || predicate(candidate)) result.push(candidate);
          if (n && result.length === n) return result;
        }

        node = queue.pop();
        if (node) node = node.node;
      }

      return result;
    }

    function compareDist(a, b) {
      return a.dist - b.dist;
    }

    function boxDist(x, y, box) {
      var dx = axisDist(x, box.minX, box.maxX),
          dy = axisDist(y, box.minY, box.maxY);
      return dx * dx + dy * dy;
    }

    function axisDist(k, min, max) {
      return k < min ? min - k : k <= max ? 0 : k - max;
    }
  }, {
    "tinyqueue": 10
  }],
  9: [function (require, module, exports) {
    'use strict';

    module.exports = rbush;
    module.exports.default = rbush;

    var quickselect = require('quickselect');

    function rbush(maxEntries, format) {
      if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance

      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

      if (format) {
        this._initFormat(format);
      }

      this.clear();
    }

    rbush.prototype = {
      all: function all() {
        return this._all(this.data, []);
      },
      search: function search(bbox) {
        var node = this.data,
            result = [],
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return result;
        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
              if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return result;
      },
      collides: function collides(bbox) {
        var node = this.data,
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return false;
        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) return true;
              nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return false;
      },
      load: function load(data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
          for (var i = 0, len = data.length; i < len; i++) {
            this.insert(data[i]);
          }

          return this;
        } // recursively build the tree with the given data from scratch using OMT algorithm


        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
          // save as is if tree is empty
          this.data = node;
        } else if (this.data.height === node.height) {
          // split root if trees have the same height
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            // swap trees if inserted one is bigger
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          } // insert the small tree into the large tree at appropriate level


          this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
      },
      insert: function insert(item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
      },
      clear: function clear() {
        this.data = createNode([]);
        return this;
      },
      remove: function remove(item, equalsFn) {
        if (!item) return this;
        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i,
            parent,
            index,
            goingUp; // depth-first iterative tree traversal

        while (node || path.length) {
          if (!node) {
            // go up
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }

          if (node.leaf) {
            // check current node
            index = findItem(item, node.children, equalsFn);

            if (index !== -1) {
              // item found, remove the item and condense tree upwards
              node.children.splice(index, 1);
              path.push(node);

              this._condense(path);

              return this;
            }
          }

          if (!goingUp && !node.leaf && contains(node, bbox)) {
            // go down
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            // go right
            i++;
            node = parent.children[i];
            goingUp = false;
          } else node = null; // nothing found

        }

        return this;
      },
      toBBox: function toBBox(item) {
        return item;
      },
      compareMinX: compareNodeMinX,
      compareMinY: compareNodeMinY,
      toJSON: function toJSON() {
        return this.data;
      },
      fromJSON: function fromJSON(data) {
        this.data = data;
        return this;
      },
      _all: function _all(node, result) {
        var nodesToSearch = [];

        while (node) {
          if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);
          node = nodesToSearch.pop();
        }

        return result;
      },
      _build: function _build(items, left, right, height) {
        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
          // reached leaf level; return leaf
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }

        if (!height) {
          // target height of the bulk-loaded tree
          height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization

          M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height; // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i,
            j,
            right2,
            right3;
        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {
          right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);

          for (j = i; j <= right2; j += N2) {
            right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively

            node.children.push(this._build(items, j, right3, height - 1));
          }
        }

        calcBBox(node, this.toBBox);
        return node;
      },
      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {
        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) break;
          minArea = minEnlargement = Infinity;

          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            area = bboxArea(child);
            enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement

            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              // otherwise choose one with the smallest area
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }

          node = targetNode || node.children[0];
        }

        return node;
      },
      _insert: function _insert(item, level, isNode) {
        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too

        var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node


        node.children.push(item);
        extend(node, bbox); // split on node overflow; propagate upwards if necessary

        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);

            level--;
          } else break;
        } // adjust bboxes along the insertion path


        this._adjustParentBBoxes(bbox, insertPath, level);
      },
      // split overflowed node into two
      _split: function _split(insertPath, level) {
        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);
      },
      _splitRoot: function _splitRoot(node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      },
      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {
        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
          bbox1 = distBBox(node, 0, i, this.toBBox);
          bbox2 = distBBox(node, i, M, this.toBBox);
          overlap = intersectionArea(bbox1, bbox2);
          area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap

          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            // otherwise choose distribution with minimum area
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }

        return index;
      },
      // sorts node children by the best axis for split
      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY


        if (xMargin < yMargin) node.children.sort(compareMinX);
      },
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin: function _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i,
            child;

        for (i = m; i < M - m; i++) {
          child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
          child = node.children[i];
          extend(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }

        return margin;
      },
      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
        }
      },
      _condense: function _condense(path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else this.clear();
          } else calcBBox(path[i], this.toBBox);
        }
      },
      _initFormat: function _initFormat(format) {
        // data format (minX, minY, maxX, maxY accessors)
        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls
        var compareArr = ['return a', ' - b', ';'];
        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
        this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
      }
    };

    function findItem(item, items, equalsFn) {
      if (!equalsFn) return items.indexOf(item);

      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
      }

      return -1;
    } // calculate node's bbox from bboxes of its children


    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    } // min bounding rectangle of node children from k to p-1


    function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) destNode = createNode(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
    }

    function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
    }

    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }

    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }

    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }

    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }

    function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }

    function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX),
          minY = Math.max(a.minY, b.minY),
          maxX = Math.min(a.maxX, b.maxX),
          maxY = Math.min(a.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }

    function contains(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }

    function intersects(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }

    function createNode(children) {
      return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    } // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach


    function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right],
          mid;

      while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n) continue;
        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);
        stack.push(left, mid, mid, right);
      }
    }
  }, {
    "quickselect": 7
  }],
  10: [function (require, module, exports) {
    'use strict';

    module.exports = TinyQueue;
    module.exports.default = TinyQueue;

    function TinyQueue(data, compare) {
      if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);
      this.data = data || [];
      this.length = this.data.length;
      this.compare = compare || defaultCompare;

      if (this.length > 0) {
        for (var i = (this.length >> 1) - 1; i >= 0; i--) {
          this._down(i);
        }
      }
    }

    function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }

    TinyQueue.prototype = {
      push: function push(item) {
        this.data.push(item);
        this.length++;

        this._up(this.length - 1);
      },
      pop: function pop() {
        if (this.length === 0) return undefined;
        var top = this.data[0];
        this.length--;

        if (this.length > 0) {
          this.data[0] = this.data[this.length];

          this._down(0);
        }

        this.data.pop();
        return top;
      },
      peek: function peek() {
        return this.data[0];
      },
      _up: function _up(pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];

        while (pos > 0) {
          var parent = pos - 1 >> 1;
          var current = data[parent];
          if (compare(item, current) >= 0) break;
          data[pos] = current;
          pos = parent;
        }

        data[pos] = item;
      },
      _down: function _down(pos) {
        var data = this.data;
        var compare = this.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];

        while (pos < halfLength) {
          var left = (pos << 1) + 1;
          var right = left + 1;
          var best = data[left];

          if (right < this.length && compare(data[right], best) < 0) {
            left = right;
            best = data[right];
          }

          if (compare(best, item) >= 0) break;
          data[pos] = best;
          pos = left;
        }

        data[pos] = item;
      }
    };
  }, {}],
  11: [function (require, module, exports) {
    ;

    (function inject(clean, precision, undef) {
      var isArray = function isArray(a) {
        return Object.prototype.toString.call(a) === "[object Array]";
      };

      var defined = function defined(a) {
        return a !== undef;
      };

      function Vec2(x, y) {
        if (!(this instanceof Vec2)) {
          return new Vec2(x, y);
        }

        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else if ('object' === _typeof(x) && x) {
          y = x.y;
          x = x.x;
        }

        this.x = Vec2.clean(x || 0);
        this.y = Vec2.clean(y || 0);
      }

      Vec2.prototype = {
        change: function change(fn) {
          if (typeof fn === 'function') {
            if (this.observers) {
              this.observers.push(fn);
            } else {
              this.observers = [fn];
            }
          } else if (this.observers && this.observers.length) {
            for (var i = this.observers.length - 1; i >= 0; i--) {
              this.observers[i](this, fn);
            }
          }

          return this;
        },
        ignore: function ignore(fn) {
          if (this.observers) {
            if (!fn) {
              this.observers = [];
            } else {
              var o = this.observers,
                  l = o.length;

              while (l--) {
                o[l] === fn && o.splice(l, 1);
              }
            }
          }

          return this;
        },
        // set x and y
        set: function set(x, y, notify) {
          if ('number' != typeof x) {
            notify = y;
            y = x.y;
            x = x.x;
          }

          if (this.x === x && this.y === y) {
            return this;
          }

          var orig = null;

          if (notify !== false && this.observers && this.observers.length) {
            orig = this.clone();
          }

          this.x = Vec2.clean(x);
          this.y = Vec2.clean(y);

          if (notify !== false) {
            return this.change(orig);
          }
        },
        // reset x and y to zero
        zero: function zero() {
          return this.set(0, 0);
        },
        // return a new vector with the same component values
        // as this one
        clone: function clone() {
          return new this.constructor(this.x, this.y);
        },
        // negate the values of this vector
        negate: function negate(returnNew) {
          if (returnNew) {
            return new this.constructor(-this.x, -this.y);
          } else {
            return this.set(-this.x, -this.y);
          }
        },
        // Add the incoming `vec2` vector to this vector
        add: function add(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          }

          x += this.x;
          y += this.y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            // Return a new vector if `returnNew` is truthy
            return new this.constructor(x, y);
          }
        },
        // Subtract the incoming `vec2` from this vector
        subtract: function subtract(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          }

          x = this.x - x;
          y = this.y - y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            // Return a new vector if `returnNew` is truthy
            return new this.constructor(x, y);
          }
        },
        // Multiply this vector by the incoming `vec2`
        multiply: function multiply(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          } else if (typeof y != 'number') {
            returnNew = y;
            y = x;
          }

          x *= this.x;
          y *= this.y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            return new this.constructor(x, y);
          }
        },
        // Rotate this vector. Accepts a `Rotation` or angle in radians.
        //
        // Passing a truthy `inverse` will cause the rotation to
        // be reversed.
        //
        // If `returnNew` is truthy, a new
        // `Vec2` will be created with the values resulting from
        // the rotation. Otherwise the rotation will be applied
        // to this vector directly, and this vector will be returned.
        rotate: function rotate(r, inverse, returnNew) {
          var x = this.x,
              y = this.y,
              cos = Math.cos(r),
              sin = Math.sin(r),
              rx,
              ry;
          inverse = inverse ? -1 : 1;
          rx = cos * x - inverse * sin * y;
          ry = inverse * sin * x + cos * y;

          if (returnNew) {
            return new this.constructor(rx, ry);
          } else {
            return this.set(rx, ry);
          }
        },
        // Calculate the length of this vector
        length: function length() {
          var x = this.x,
              y = this.y;
          return Math.sqrt(x * x + y * y);
        },
        // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).
        lengthSquared: function lengthSquared() {
          var x = this.x,
              y = this.y;
          return x * x + y * y;
        },
        // Return the distance betwen this `Vec2` and the incoming vec2 vector
        // and return a scalar
        distance: function distance(vec2) {
          var x = this.x - vec2.x;
          var y = this.y - vec2.y;
          return Math.sqrt(x * x + y * y);
        },
        // Given Array of Vec2, find closest to this Vec2.
        nearest: function nearest(others) {
          var shortestDistance = Number.MAX_VALUE,
              nearest = null,
              currentDistance;

          for (var i = others.length - 1; i >= 0; i--) {
            currentDistance = this.distance(others[i]);

            if (currentDistance <= shortestDistance) {
              shortestDistance = currentDistance;
              nearest = others[i];
            }
          }

          return nearest;
        },
        // Convert this vector into a unit vector.
        // Returns the length.
        normalize: function normalize(returnNew) {
          var length = this.length(); // Collect a ratio to shrink the x and y coords

          var invertedLength = length < Number.MIN_VALUE ? 0 : 1 / length;

          if (!returnNew) {
            // Convert the coords to be greater than zero
            // but smaller than or equal to 1.0
            return this.set(this.x * invertedLength, this.y * invertedLength);
          } else {
            return new this.constructor(this.x * invertedLength, this.y * invertedLength);
          }
        },
        // Determine if another `Vec2`'s components match this one's
        // also accepts 2 scalars
        equal: function equal(v, w) {
          if (typeof v != 'number') {
            if (isArray(v)) {
              w = v[1];
              v = v[0];
            } else {
              w = v.y;
              v = v.x;
            }
          }

          return Vec2.clean(v) === this.x && Vec2.clean(w) === this.y;
        },
        // Return a new `Vec2` that contains the absolute value of
        // each of this vector's parts
        abs: function abs(returnNew) {
          var x = Math.abs(this.x),
              y = Math.abs(this.y);

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Return a new `Vec2` consisting of the smallest values
        // from this vector and the incoming
        //
        // When returnNew is truthy, a new `Vec2` will be returned
        // otherwise the minimum values in either this or `v` will
        // be applied to this vector.
        min: function min(v, returnNew) {
          var tx = this.x,
              ty = this.y,
              vx = v.x,
              vy = v.y,
              x = tx < vx ? tx : vx,
              y = ty < vy ? ty : vy;

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Return a new `Vec2` consisting of the largest values
        // from this vector and the incoming
        //
        // When returnNew is truthy, a new `Vec2` will be returned
        // otherwise the minimum values in either this or `v` will
        // be applied to this vector.
        max: function max(v, returnNew) {
          var tx = this.x,
              ty = this.y,
              vx = v.x,
              vy = v.y,
              x = tx > vx ? tx : vx,
              y = ty > vy ? ty : vy;

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Clamp values into a range.
        // If this vector's values are lower than the `low`'s
        // values, then raise them.  If they are higher than
        // `high`'s then lower them.
        //
        // Passing returnNew as true will cause a new Vec2 to be
        // returned.  Otherwise, this vector's values will be clamped
        clamp: function clamp(low, high, returnNew) {
          var ret = this.min(high, true).max(low);

          if (returnNew) {
            return ret;
          } else {
            return this.set(ret.x, ret.y);
          }
        },
        // Perform linear interpolation between two vectors
        // amount is a decimal between 0 and 1
        lerp: function lerp(vec, amount, returnNew) {
          return this.add(vec.subtract(this, true).multiply(amount), returnNew);
        },
        // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
        skew: function skew(returnNew) {
          if (!returnNew) {
            return this.set(-this.y, this.x);
          } else {
            return new this.constructor(-this.y, this.x);
          }
        },
        // calculate the dot product between
        // this vector and the incoming
        dot: function dot(b) {
          return Vec2.clean(this.x * b.x + b.y * this.y);
        },
        // calculate the perpendicular dot product between
        // this vector and the incoming
        perpDot: function perpDot(b) {
          return Vec2.clean(this.x * b.y - this.y * b.x);
        },
        // Determine the angle between two vec2s
        angleTo: function angleTo(vec) {
          return Math.atan2(this.perpDot(vec), this.dot(vec));
        },
        // Divide this vector's components by a scalar
        divide: function divide(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          } else if (typeof y != 'number') {
            returnNew = y;
            y = x;
          }

          if (x === 0 || y === 0) {
            throw new Error('division by zero');
          }

          if (isNaN(x) || isNaN(y)) {
            throw new Error('NaN detected');
          }

          if (returnNew) {
            return new this.constructor(this.x / x, this.y / y);
          }

          return this.set(this.x / x, this.y / y);
        },
        isPointOnLine: function isPointOnLine(start, end) {
          return (start.y - this.y) * (start.x - end.x) === (start.y - end.y) * (start.x - this.x);
        },
        toArray: function toArray() {
          return [this.x, this.y];
        },
        fromArray: function fromArray(array) {
          return this.set(array[0], array[1]);
        },
        toJSON: function toJSON() {
          return {
            x: this.x,
            y: this.y
          };
        },
        toString: function toString() {
          return '(' + this.x + ', ' + this.y + ')';
        },
        constructor: Vec2
      };

      Vec2.fromArray = function (array, ctor) {
        return new (ctor || Vec2)(array[0], array[1]);
      }; // Floating point stability


      Vec2.precision = precision || 8;
      var p = Math.pow(10, Vec2.precision);

      Vec2.clean = clean || function (val) {
        if (isNaN(val)) {
          throw new Error('NaN detected');
        }

        if (!isFinite(val)) {
          throw new Error('Infinity detected');
        }

        if (Math.round(val) === val) {
          return val;
        }

        return Math.round(val * p) / p;
      };

      Vec2.inject = inject;

      if (!clean) {
        Vec2.fast = inject(function (k) {
          return k;
        }); // Expose, but also allow creating a fresh Vec2 subclass.

        if (typeof module !== 'undefined' && _typeof(module.exports) == 'object') {
          module.exports = Vec2;
        } else {
          window.Vec2 = window.Vec2 || Vec2;
        }
      }

      return Vec2;
    })();
  }, {}]
}, {}, [2]);