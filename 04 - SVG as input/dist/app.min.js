"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw a.code = "MODULE_NOT_FOUND", a;
        }

        var p = n[i] = {
          exports: {}
        };
        e[i][0].call(p.exports, function (r) {
          var n = e[i][1][r];
          return o(n || r);
        }, p, p.exports, r, e, n, t);
      }

      return n[i].exports;
    }

    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
      o(t[i]);
    }

    return o;
  }

  return r;
})()({
  1: [function (require, module, exports) {
    module.exports = {
      SeedRadius: 100,
      MinDistance: 1,
      MaxDistance: 5,
      RepulsionRadius: 10,
      MaxVelocity: .1,
      AttractionForce: .2,
      RepulsionForce: .6,
      AlignmentForce: .55,
      ScreenPadding: 20,
      MaxNodes: 10000,
      NodeInjectionInterval: 100,
      DrawNodes: false,
      TraceMode: false,
      InvertedColors: false,
      DebugMode: false,
      FillMode: false,
      BrownianMotionRange: .01
    };
  }, {}],
  2: [function (require, module, exports) {
    var Node = require('../../core/Node'),
        Path = require('../../core/Path'),
        World = require('../../core/World'),
        Settings = require('./Settings'),
        _require = require('../../core/node_modules/svg-pathdata'),
        SVGPathData = _require.SVGPathData,
        SVGPathDataTransformer = _require.SVGPathDataTransformer,
        SVGPathDataEncoder = _require.SVGPathDataEncoder,
        SVGPathDataParser = _require.SVGPathDataParser;

    var world;
    /*
    =============================================================================
      Main sketch
    =============================================================================
    */

    var sketch = function sketch(p5) {
      // Setup -------------------------------------------------------------
      p5.setup = function () {
        p5.createCanvas(window.innerWidth, window.innerHeight);
        p5.colorMode(p5.HSB, 255); // Set up world and begin simulation

        world = new World(p5, Settings);
        restartWorld();
      }; // Draw ---------------------------------------------------------------


      p5.draw = function () {
        world.iterate();
        world.draw();
      }; // Restart the simulation ---------------------------------------------


      function restartWorld() {
        world.clearPaths(); // Load the default SVG file

        var svg = document.getElementById('hello-world-serif');
        var inputPaths = svg.contentDocument.querySelectorAll('path');
        var currentPath = new Path(p5, [], Settings, true); // Scrape all points from all points, and record breakpoints

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = inputPaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var inputPath = _step.value;
            var pathData = new SVGPathData(inputPath.getAttribute('d'));
            var previousCoords = {
              x: 500,
              y: 500
            };
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = pathData.commands[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var command = _step2.value;

                switch (command.type) {
                  case SVGPathData.MOVE_TO:
                  case SVGPathData.LINE_TO:
                    currentPath.addNode(new Node(p5, command.x, command.y, Settings));
                    break;

                  case SVGPathData.HORIZ_LINE_TO:
                    currentPath.addNode(new Node(p5, command.x, previousCoords.y, Settings));
                    break;

                  case SVGPathData.VERT_LINE_TO:
                    currentPath.addNode(new Node(p5, previousCoords.x, command.y, Settings));
                    break;

                  case SVGPathData.CLOSE_PATH:
                    currentPath.scale(10);
                    currentPath.moveTo(window.innerWidth / 2 - 600, window.innerHeight / 2 - 150);
                    world.addPath(currentPath);
                    currentPath = new Path(p5, [], Settings, true);
                    break;
                }

                if (command.hasOwnProperty('x')) {
                  previousCoords.x = command.x;
                }

                if (command.hasOwnProperty('y')) {
                  previousCoords.y = command.y;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          } // Draw the first frame, then pause

        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        world.drawBackground();
        world.draw();
        world.pause(); // Unpause simulation after 1s

        setTimeout(function () {
          world.unpause();
        }, 1000);
      }
      /*
      =============================================================================
        Key handler
      =============================================================================
      */


      p5.keyReleased = function () {
        switch (p5.key) {
          // Toggle trace mode with 't'
          case 't':
            world.toggleTraceMode();
            break;
          // Toggle drawing of nodes with 'n'

          case 'n':
            world.setDrawNodes(!world.getDrawNodes());
            break;
          // Reset simulation with current parameters with 'r'

          case 'r':
            restartWorld();
            break;
          // Toggle pause with Space

          case ' ':
            world.paused = !world.paused;
            break;
          // Invert colors with 'i'

          case 'i':
            world.toggleInvertedColors();
            world.drawBackground();
            break;
          // Toggle debug mode with 'd'

          case 'd':
            world.toggleDebugMode();
            break;
          // Toggle fill for all shapes with 'f'

          case 'f':
            world.toggleFillMode();
            break;
          // Export SVG with 's'
        }
      };
    }; // Launch the sketch using p5js in instantiated mode


    new p5(sketch);
  }, {
    "../../core/Node": 4,
    "../../core/Path": 5,
    "../../core/World": 6,
    "../../core/node_modules/svg-pathdata": 10,
    "./Settings": 1
  }],
  3: [function (require, module, exports) {
    module.exports = {
      MinDistance: 20,
      // injection, attraction
      MaxDistance: 30,
      // split
      RepulsionRadius: 20,
      MaxVelocity: .1,
      Acceleration: .1,
      AttractionForce: .001,
      RepulsionForce: 500,
      AlignmentForce: .001,
      ScreenPadding: 20,
      MaxNodes: 3000,
      NodeInjectionInterval: 100,
      DrawNodes: false,
      TraceMode: false,
      UseBrownianMotion: false,
      BrownianMotionRange: 0.01
    };
  }, {}],
  4: [function (require, module, exports) {
    var Vec2 = require('./node_modules/vec2'),
        Defaults = require('./Defaults');
    /*
    =============================================================================
      Node class
    
      A Node is a single point on the canvas whose only job is to manage
      it's position and movement towards new position. 
    =============================================================================
    */


    var Node =
    /*#__PURE__*/
    function (_Vec) {
      _inherits(Node, _Vec);

      function Node(p5, x, y) {
        var _this;

        var settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Defaults;
        var isFixed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

        _classCallCheck(this, Node);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Node).call(this, x, y));
        _this.p5 = p5;
        _this.isFixed = isFixed;
        _this.settings = settings;
        _this.velocity = 0;
        _this.nextPosition = new Vec2(x, y);
        return _this;
      }

      _createClass(Node, [{
        key: "iterate",
        value: function iterate() {
          if (!this.isFixed) {
            this.x = this.p5.lerp(this.x, this.nextPosition.x, this.settings.MaxVelocity);
            this.y = this.p5.lerp(this.y, this.nextPosition.y, this.settings.MaxVelocity);
          }
        }
      }, {
        key: "draw",
        value: function draw() {
          if (this.isFixed) {
            this.p5.ellipse(this.x, this.y, 20);
          } else {
            this.p5.ellipse(this.x, this.y, 5);
          }
        }
      }]);

      return Node;
    }(Vec2);

    module.exports = Node;
  }, {
    "./Defaults": 3,
    "./node_modules/vec2": 12
  }],
  5: [function (require, module, exports) {
    var knn = require('./node_modules/rbush-knn');

    Node = require('./Node');
    /*
    =============================================================================
      Path class
    
      A Path manages a set of Nodes in a continuous, ordered
      data structure (an Array). 
    =============================================================================
    */

    var Path =
    /*#__PURE__*/
    function () {
      function Path(p5, nodes) {
        var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Defaults;
        var isClosed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var fillColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {
          h: 0,
          s: 0,
          b: 0,
          a: 255
        };
        var strokeColor = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {
          h: 0,
          s: 0,
          b: 0,
          a: 255
        };
        var invertedFillColor = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : {
          h: 0,
          s: 0,
          b: 255,
          a: 255
        };
        var invertedStrokeColor = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : {
          h: 0,
          s: 0,
          b: 255,
          a: 255
        };

        _classCallCheck(this, Path);

        this.p5 = p5;
        this.nodes = nodes;
        this.isClosed = isClosed;
        this.settings = settings;
        this.injectionMode = "RANDOM";
        this.lastNodeInjectTime = 0;
        this.drawNodes = this.settings.DrawNodes;
        this.invertedColors = this.settings.InvertedColors;
        this.traceMode = this.settings.TraceMode;
        this.debugMode = this.settings.DebugMode;
        this.fillMode = this.settings.FillMode;
        this.useBrownianMotion = this.settings.UseBrownianMotion;
        this.fillColor = fillColor;
        this.strokeColor = strokeColor;
        this.invertedFillColor = invertedFillColor;
        this.invertedStrokeColor = invertedStrokeColor;
        this.currentFillColor = this.fillColor;
        this.currentStrokeColor = this.strokeColor;

        if (this.invertedColors) {
          this.currentFillColor = this.invertedFillColor;
          this.currentStrokeColor = this.invertedStrokeColor;
        }
      } //------------------------------------------------------------------
      //  Iterate
      //  =======
      //  Run a single 'tick' of the simulation 
      //-----------------------------------------------------------------


      _createClass(Path, [{
        key: "iterate",
        value: function iterate(tree) {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this.nodes.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _step3$value = _slicedToArray(_step3.value, 2),
                  index = _step3$value[0],
                  node = _step3$value[1];

              // Apply Brownian motion to realistically 'jiggle' nodes
              if (this.useBrownianMotion) {
                this.applyBrownianMotion(index);
              } // Move towards neighbors (attraction), if there is space to move


              this.applyAttraction(index); // Move away from any nodes that are too close (repulsion)

              this.applyRepulsion(index, tree); // Align with neighbors

              this.applyAlignment(index); // Constrain to the screen

              this.avoidWalls(index); // Move towards next position

              node.iterate();
            } // Split any edges that have become too long

          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          this.splitEdges(); // Remove any nodes that are too close to other nodes

          this.pruneNodes(); // Inject a new node to introduce asymmetry every so often

          if (this.p5.millis() - this.lastNodeInjectTime >= this.settings.NodeInjectionInterval && this.nodes.length < this.settings.MaxNodes) {
            this.injectNode();
            this.lastNodeInjectTime = this.p5.millis();
          }
        } //---------------------------------------------------------------------
        //  Brownian motion
        //  ===============
        //  Simulate the random

      }, {
        key: "applyBrownianMotion",
        value: function applyBrownianMotion(index) {
          this.nodes[index].x += this.p5.random(-this.settings.BrownianMotionRange / 2, this.settings.BrownianMotionRange / 2);
          this.nodes[index].y += this.p5.random(-this.settings.BrownianMotionRange / 2, this.settings.BrownianMotionRange / 2);
        } //---------------------------------------------------------------------
        //  Attraction
        //  ==========
        //  Move the referenced node closer to it's connected neighbor nodes
        //---------------------------------------------------------------------

      }, {
        key: "applyAttraction",
        value: function applyAttraction(index) {
          var distance;
          var connectedNodes = this.getConnectedNodes(index); // Move towards next node, if there is one

          if (connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && !this.nodes[index].isFixed) {
            distance = this.nodes[index].distance(connectedNodes.nextNode);

            if (distance > this.settings.MinDistance) {
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, connectedNodes.nextNode.x, this.settings.AttractionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, connectedNodes.nextNode.y, this.settings.AttractionForce);
            }
          } // Move towards previous node, if there is one


          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && !this.nodes[index].isFixed) {
            distance = this.nodes[index].distance(connectedNodes.previousNode);

            if (distance > this.settings.MinDistance) {
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, connectedNodes.previousNode.x, this.settings.AttractionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, connectedNodes.previousNode.y, this.settings.AttractionForce);
            }
          }
        } //------------------------------------------------------------------------
        //  Repulsion
        //  =========
        //  Move the referenced node away from all nearby nodes within a radius
        //------------------------------------------------------------------------

      }, {
        key: "applyRepulsion",
        value: function applyRepulsion(index, tree) {
          // Perform knn search to find all neighbors within certain radius
          var neighbors = knn(tree, this.nodes[index].x, this.nodes[index].y, undefined, undefined, this.settings.RepulsionRadius * this.settings.RepulsionRadius); // radius must be squared as per https://github.com/mourner/rbush-knn/issues/13
          // Move this node away from all nearby neighbors
          // TODO: Make this proportional to distance?

          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = neighbors[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var node = _step4.value;
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].x, node.x, -this.settings.RepulsionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].y, node.y, -this.settings.RepulsionForce);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        } //-------------------------------------------------------------
        //  Alignment
        //  =========
        //  Move the referenced node closer to the midpoint of it's
        //  neighbor connected nodes to minimize curvature
        //-------------------------------------------------------------

      }, {
        key: "applyAlignment",
        value: function applyAlignment(index) {
          var connectedNodes = this.getConnectedNodes(index);

          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && !this.nodes[index].isFixed) {
            // Find the midpoint between the neighbors of this node
            var midpoint = this.getMidpointNode(connectedNodes.previousNode, connectedNodes.nextNode); // Move this point towards this midpoint

            this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, midpoint.x, this.settings.AlignmentForce);
            this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, midpoint.y, this.settings.AlignmentForce);
          }
        } //--------------------------------------------------------------
        //  Split edges
        //  ===========
        //  Search for long edges, then inject a new node when found
        //--------------------------------------------------------------

      }, {
        key: "splitEdges",
        value: function splitEdges() {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = this.nodes.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  index = _step5$value[0],
                  node = _step5$value[1];

              var connectedNodes = this.getConnectedNodes(index);

              if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && node.distance(connectedNodes.previousNode) >= this.settings.MaxDistance && this.nodes.length < this.settings.MaxNodes) {
                var midpointNode = this.getMidpointNode(node, connectedNodes.previousNode); // Inject the new midpoint node into the global list

                if (index == 0) {
                  this.nodes.splice(this.nodes.length, 0, midpointNode);
                } else {
                  this.nodes.splice(index, 0, midpointNode);
                }
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        } //------------------------------------------------------------
        //  Prune nodes
        //  ===========
        //  Remove nodes when they are too close to their neighbors
        //------------------------------------------------------------

      }, {
        key: "pruneNodes",
        value: function pruneNodes() {
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = undefined;

          try {
            for (var _iterator6 = this.nodes.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var _step6$value = _slicedToArray(_step6.value, 2),
                  index = _step6$value[0],
                  node = _step6$value[1];

              var connectedNodes = this.getConnectedNodes(index);

              if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && node.distance(connectedNodes.previousNode) < this.settings.MinDistance) {
                if (index == 0) {
                  if (!this.nodes[this.nodes.length - 1].isFixed) {
                    this.nodes.splice(this.nodes.length - 1, 1);
                  }
                } else {
                  if (!this.nodes[index - 1].isFixed) {
                    this.nodes.splice(index - 1, 1);
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        } //---------------------------------------------------
        //  Inject a node
        //  =============
        //  Create a new node between two existing nodes
        //---------------------------------------------------

      }, {
        key: "injectNode",
        value: function injectNode() {
          switch (this.injectionMode) {
            case "RANDOM":
              this.injectRandomNode();
              break;

            case "CURVATURE":
              this.injectNodeByCurvature();
              break;
          }
        } // Inject a new node in a random location, if there is space for it

      }, {
        key: "injectRandomNode",
        value: function injectRandomNode() {
          // Choose two connected nodes at random
          var index = parseInt(this.p5.random(1, this.nodes.length));
          var connectedNodes = this.getConnectedNodes(index);

          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && this.nodes[index].distance(connectedNodes.previousNode) > this.settings.MinDistance) {
            // Create a new node in the middle
            var midpointNode = this.getMidpointNode(this.nodes[index], connectedNodes.previousNode); // Splice new node into array

            this.nodes.splice(index, 0, midpointNode);
          }
        } // Inject new node nodes when curvature is too high
        // - When the angle between connected nodes is too high, remove
        //   the middle node and replace it with two nodes at the respective
        //   midpoints of the previous two lines. This "truncates" or "chamfers"
        //   the pointy node into two flatter nodes.

      }, {
        key: "injectNodeByCurvature",
        value: function injectNodeByCurvature() {
          console.log('test');
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = this.nodes.entries()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var _step7$value = _slicedToArray(_step7.value, 2),
                  index = _step7$value[0],
                  node = _step7$value[1];

              var connectedNodes = this.getConnectedNodes(index); // Find angle between adjacent nodes

              var a = node.distance(connectedNodes.previousNode);
              var b = node.distance(connectedNodes.nextNode);
              var angle = Math.atan(a / b) * 180 / Math.PI; // If angle is below a certain angle (high curvature), replace the current node with two nodes

              if (angle < 30) {
                console.log(index);
                var previousMidpointNode = this.getMidpointNode(node, connectedNodes.previousNode);
                var nextMidpointNode = this.getMidpointNode(node, connectedNodes.nextNode);
                console.log(previousMidpointNode);
                console.log(nextMidpointNode);
                this.p5.noLoop(); // console.log(previousMidpointNode);
                // console.log(nextMidpointNode);
                // Replace this node with the two new nodes

                if (index == 0) {
                  this.nodes.splice(this.nodes.length - 1, 0, previousMidpointNode);
                  this.nodes.splice(0, 1, nextMidpointNode);
                } else {
                  // console.log(index);
                  // console.log(this.nodes);
                  this.nodes.splice(index, 1, previousMidpointNode, nextMidpointNode); // console.log(this.nodes);
                  // this.p5.noLoop();
                }
              }
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
        } //------------------------------------------------------------------
        //  Avoid walls
        //  ===========
        //  Clamp node position to the window to prevent "runaway" growth  
        //------------------------------------------------------------------

      }, {
        key: "avoidWalls",
        value: function avoidWalls(index) {
          this.nodes[index].x = this.p5.constrain(this.nodes[index].x, 0, window.innerWidth);
          this.nodes[index].y = this.p5.constrain(this.nodes[index].y, 0, window.innerHeight);
        } //------------------------------------------------------------
        //  Get connected nodes
        //  ===================
        //  For a given node, find and return the nodes that come 
        //  immediately before and after it.
        //------------------------------------------------------------

      }, {
        key: "getConnectedNodes",
        value: function getConnectedNodes(index) {
          var previousNode, nextNode; // Find previous node, if there is one

          if (index == 0 && this.isClosed) {
            previousNode = this.nodes[this.nodes.length - 1];
          } else if (index >= 1) {
            previousNode = this.nodes[index - 1];
          } // Find next node, if there is one


          if (index == this.nodes.length - 1 && this.isClosed) {
            nextNode = this.nodes[0];
          } else if (index <= this.nodes.length - 1) {
            nextNode = this.nodes[index + 1];
          }

          return {
            previousNode: previousNode,
            nextNode: nextNode
          };
        } //------------------------------------------------------------
        //  Get midpoint node
        //  =================
        //  Create and return a node exactly halfway between the
        //  two provided nodes.
        //------------------------------------------------------------

      }, {
        key: "getMidpointNode",
        value: function getMidpointNode(node1, node2) {
          var fixed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          return new Node(this.p5, (node1.x + node2.x) / 2, (node1.y + node2.y) / 2, this.settings, fixed);
        } //--------------------------------------------
        //  Draw
        //  ====
        //  Draw all nodes and edges to the canvas
        //--------------------------------------------

      }, {
        key: "draw",
        value: function draw() {
          // Set shape fill 
          if (this.fillMode) {
            this.p5.fill(this.currentFillColor.h, this.currentFillColor.s, this.currentFillColor.b, this.currentFillColor.a);
          } else {
            this.p5.noFill();
          } // Set stroke color


          this.p5.stroke(this.currentStrokeColor.h, this.currentStrokeColor.s, this.currentStrokeColor.b, this.currentStrokeColor.a); // Begin capturing vertices

          if (!this.debugMode) {
            this.p5.beginShape();
          } // Create vertices or lines (if debug mode)


          for (var i = 0; i < this.nodes.length; i++) {
            if (!this.debugMode) {
              this.p5.vertex(this.nodes[i].x, this.nodes[i].y);
            } else {
              // In debug mode each line has a unique stroke color, which isn't possible with begin/endShape(). Instead we'll use line()
              if (i > 0) {
                if (!this.traceMode) {
                  this.p5.stroke(this.p5.map(i, 0, this.nodes.length - 1, 0, 255, true), 255, 255, 255);
                } else {
                  this.p5.stroke(this.p5.map(i, 0, this.nodes.length - 1, 0, 255, true), 255, 255, 2);
                }

                this.p5.line(this.nodes[i - 1].x, this.nodes[i - 1].y, this.nodes[i].x, this.nodes[i].y);
              }
            }
          } // For closed paths, connect the last and first nodes


          if (this.isClosed) {
            if (!this.debugMode) {
              this.p5.vertex(this.nodes[0].x, this.nodes[0].y);
            } else {
              this.p5.line(this.nodes[this.nodes.length - 1].x, this.nodes[this.nodes.length - 1].y, this.nodes[0].x, this.nodes[0].y);
            }
          } // Stop capturing vertices


          if (!this.debugMode) {
            this.p5.endShape();
          } // Draw all nodes


          if (this.drawNodes) {
            this.p5.noStroke();

            if (!this.invertedColors) {
              this.p5.fill(0);
            } else {
              this.p5.fill(255);
            }

            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
              for (var _iterator8 = this.nodes.entries()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var _step8$value = _slicedToArray(_step8.value, 2),
                    index = _step8$value[0],
                    node = _step8$value[1];

                if (this.debugMode) {
                  this.p5.fill(this.p5.map(index, 0, this.nodes.length - 1, 0, 255, true), 255, 255, 255);
                }

                node.draw();
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          }
        } // Translate this path by the provided offsets

      }, {
        key: "moveTo",
        value: function moveTo(xOffset, yOffset) {
          var _iteratorNormalCompletion9 = true;
          var _didIteratorError9 = false;
          var _iteratorError9 = undefined;

          try {
            for (var _iterator9 = this.nodes[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
              var node = _step9.value;
              node.x += xOffset;
              node.y += yOffset;
            }
          } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
                _iterator9.return();
              }
            } finally {
              if (_didIteratorError9) {
                throw _iteratorError9;
              }
            }
          }
        } // Scale (multiply) all Nodes by the provided factor

      }, {
        key: "scale",
        value: function scale(factor) {
          var _iteratorNormalCompletion10 = true;
          var _didIteratorError10 = false;
          var _iteratorError10 = undefined;

          try {
            for (var _iterator10 = this.nodes[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
              var node = _step10.value;
              node.x *= factor;
              node.y *= factor;
            }
          } catch (err) {
            _didIteratorError10 = true;
            _iteratorError10 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
                _iterator10.return();
              }
            } finally {
              if (_didIteratorError10) {
                throw _iteratorError10;
              }
            }
          }
        } // Add a new node from outside this class

      }, {
        key: "addNode",
        value: function addNode(node) {
          this.nodes.push(node);
        } // Getters ------------------------------------

      }, {
        key: "getTraceMode",
        value: function getTraceMode() {
          return this.traceMode;
        }
      }, {
        key: "getInvertedColors",
        value: function getInvertedColors() {
          return this.invertedColors;
        } // Setters ------------------------------------

      }, {
        key: "setTraceMode",
        value: function setTraceMode(state) {
          this.traceMode = state;

          if (!this.traceMode) {
            this.currentFillColor.a = 255;
            this.currentStrokeColor.a = 255;
          } else {
            this.currentFillColor.a = 2;
            this.currentStrokeColor.a = 2;
          }
        }
      }, {
        key: "setInvertedColors",
        value: function setInvertedColors(state) {
          this.invertedColors = state;

          if (!this.invertedColors) {
            this.currentFillColor = this.fillColor;
            this.currentStrokeColor = this.strokeColor;
          } else {
            this.currentFillColor = this.invertedFillColor;
            this.currentStrokeColor = this.invertedStrokeColor;
          } // Reapply the current trace mode state to make sure opacity is adjusted when colors are inverted


          this.setTraceMode(this.traceMode);
        } // Toggles ------------------------------------

      }, {
        key: "toggleTraceMode",
        value: function toggleTraceMode() {
          this.setTraceMode(!this.getTraceMode());
        }
      }, {
        key: "toggleInvertedColors",
        value: function toggleInvertedColors() {
          this.setInvertedColors(!this.getInvertedColors());
        }
      }]);

      return Path;
    }();

    module.exports = Path;
  }, {
    "./Node": 4,
    "./node_modules/rbush-knn": 8
  }],
  6: [function (require, module, exports) {
    var rbush = require('./node_modules/rbush'),
        knn = require('./node_modules/rbush-knn'),
        Defaults = require('./Defaults');
    /*
    =============================================================================
      World class
    
      A World manages a set of Paths and provides some global control
      mechanisms, such as pausing the simulation.
    =============================================================================
    */


    var World =
    /*#__PURE__*/
    function () {
      function World(p5) {
        var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Defaults;
        var paths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

        _classCallCheck(this, World);

        this.p5 = p5;
        this.paths = paths;
        this.paused = false;
        this.settings = settings;
        this.traceMode = this.settings.TraceMode;
        this.drawNodes = this.settings.DrawNodes;
        this.debugMode = this.settings.DebugMode;
        this.invertedColors = this.settings.InvertedColors;
        this.fillMode = this.settings.FillMode;
        this.useBrownianMotion = this.settings.UseBrownianMotion;
        this.tree = rbush(9, ['.x', '.y', '.x', '.y']); // use custom accessor strings per https://github.com/mourner/rbush#data-format

        this.buildTree();
      } // Run a single tick for all paths -----------------


      _createClass(World, [{
        key: "iterate",
        value: function iterate() {
          this.buildTree();

          if (this.paths != undefined && this.paths instanceof Array && this.paths.length > 0 && !this.paused) {
            var _iteratorNormalCompletion11 = true;
            var _didIteratorError11 = false;
            var _iteratorError11 = undefined;

            try {
              for (var _iterator11 = this.paths[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                var path = _step11.value;
                path.iterate(this.tree);
              }
            } catch (err) {
              _didIteratorError11 = true;
              _iteratorError11 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
                  _iterator11.return();
                }
              } finally {
                if (_didIteratorError11) {
                  throw _iteratorError11;
                }
              }
            }
          }
        } // Draw all paths ----------------------------------

      }, {
        key: "draw",
        value: function draw() {
          if (!this.paused) {
            if (!this.traceMode) {
              this.drawBackground();
            }

            var _iteratorNormalCompletion12 = true;
            var _didIteratorError12 = false;
            var _iteratorError12 = undefined;

            try {
              for (var _iterator12 = this.paths[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
                var path = _step12.value;
                path.draw();
              }
            } catch (err) {
              _didIteratorError12 = true;
              _iteratorError12 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                  _iterator12.return();
                }
              } finally {
                if (_didIteratorError12) {
                  throw _iteratorError12;
                }
              }
            }
          }
        } // Draw the background -----------------------------

      }, {
        key: "drawBackground",
        value: function drawBackground() {
          if (!this.invertedColors) {
            this.p5.background(255);
          } else {
            this.p5.background(0);
          }
        } // Build an R-tree spatial index with all paths ----

      }, {
        key: "buildTree",
        value: function buildTree() {
          this.tree.clear();
          var _iteratorNormalCompletion13 = true;
          var _didIteratorError13 = false;
          var _iteratorError13 = undefined;

          try {
            for (var _iterator13 = this.paths[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
              var path = _step13.value;
              this.tree.load(path.nodes);
            }
          } catch (err) {
            _didIteratorError13 = true;
            _iteratorError13 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
                _iterator13.return();
              }
            } finally {
              if (_didIteratorError13) {
                throw _iteratorError13;
              }
            }
          }
        } // Add a new path to the world ---------------------

      }, {
        key: "addPath",
        value: function addPath(path) {
          // Cascade all current World settings to new path
          path.drawNodes = this.drawNodes;
          path.debugMode = this.debugMode;
          path.fillMode = this.fillMode;
          path.useBrownianMotion = this.useBrownianMotion;
          path.setInvertedColors(this.invertedColors);
          path.setTraceMode(this.traceMode);
          this.paths.push(path);
        }
      }, {
        key: "addPaths",
        value: function addPaths(paths) {
          var _iteratorNormalCompletion14 = true;
          var _didIteratorError14 = false;
          var _iteratorError14 = undefined;

          try {
            for (var _iterator14 = paths[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
              var path = _step14.value;
              this.addPath(path);
            }
          } catch (err) {
            _didIteratorError14 = true;
            _iteratorError14 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
                _iterator14.return();
              }
            } finally {
              if (_didIteratorError14) {
                throw _iteratorError14;
              }
            }
          }
        } // Remove all paths from the world -----------------

      }, {
        key: "clearPaths",
        value: function clearPaths() {
          this.paths = [];
        } // Pause the simulation ----------------------------

      }, {
        key: "pause",
        value: function pause() {
          this.paused = true;
        } // Unpause the simulation --------------------------

      }, {
        key: "unpause",
        value: function unpause() {
          this.paused = false;
        } // Getters -----------------------------------------

      }, {
        key: "getDrawNodes",
        value: function getDrawNodes() {
          return this.drawNodes;
        }
      }, {
        key: "getDebugMode",
        value: function getDebugMode() {
          return this.debugMode;
        }
      }, {
        key: "getFillMode",
        value: function getFillMode() {
          return this.fillMode;
        } // Setters -----------------------------------------

      }, {
        key: "setDrawNodes",
        value: function setDrawNodes(state) {
          var _iteratorNormalCompletion15 = true;
          var _didIteratorError15 = false;
          var _iteratorError15 = undefined;

          try {
            for (var _iterator15 = this.paths[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
              var path = _step15.value;
              path.drawNodes = state;
            }
          } catch (err) {
            _didIteratorError15 = true;
            _iteratorError15 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
                _iterator15.return();
              }
            } finally {
              if (_didIteratorError15) {
                throw _iteratorError15;
              }
            }
          }

          this.drawNodes = state;
        }
      }, {
        key: "setDebugMode",
        value: function setDebugMode(state) {
          var _iteratorNormalCompletion16 = true;
          var _didIteratorError16 = false;
          var _iteratorError16 = undefined;

          try {
            for (var _iterator16 = this.paths[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
              var path = _step16.value;
              path.debugMode = state;
            }
          } catch (err) {
            _didIteratorError16 = true;
            _iteratorError16 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
                _iterator16.return();
              }
            } finally {
              if (_didIteratorError16) {
                throw _iteratorError16;
              }
            }
          }

          this.debugMode = state;
        }
      }, {
        key: "setFillMode",
        value: function setFillMode(state) {
          var _iteratorNormalCompletion17 = true;
          var _didIteratorError17 = false;
          var _iteratorError17 = undefined;

          try {
            for (var _iterator17 = this.paths[Symbol.iterator](), _step17; !(_iteratorNormalCompletion17 = (_step17 = _iterator17.next()).done); _iteratorNormalCompletion17 = true) {
              var path = _step17.value;
              path.fillMode = state;
            }
          } catch (err) {
            _didIteratorError17 = true;
            _iteratorError17 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion17 && _iterator17.return != null) {
                _iterator17.return();
              }
            } finally {
              if (_didIteratorError17) {
                throw _iteratorError17;
              }
            }
          }

          this.fillMode = state;
        } // Toggles ----------------------------------

      }, {
        key: "toggleDrawNodes",
        value: function toggleDrawNodes() {
          this.setDrawNodes(!this.getDrawNodes());
        }
      }, {
        key: "toggleTraceMode",
        value: function toggleTraceMode() {
          var _iteratorNormalCompletion18 = true;
          var _didIteratorError18 = false;
          var _iteratorError18 = undefined;

          try {
            for (var _iterator18 = this.paths[Symbol.iterator](), _step18; !(_iteratorNormalCompletion18 = (_step18 = _iterator18.next()).done); _iteratorNormalCompletion18 = true) {
              var path = _step18.value;
              path.toggleTraceMode();
            }
          } catch (err) {
            _didIteratorError18 = true;
            _iteratorError18 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion18 && _iterator18.return != null) {
                _iterator18.return();
              }
            } finally {
              if (_didIteratorError18) {
                throw _iteratorError18;
              }
            }
          }

          this.traceMode = !this.traceMode;
        }
      }, {
        key: "toggleInvertedColors",
        value: function toggleInvertedColors() {
          var _iteratorNormalCompletion19 = true;
          var _didIteratorError19 = false;
          var _iteratorError19 = undefined;

          try {
            for (var _iterator19 = this.paths[Symbol.iterator](), _step19; !(_iteratorNormalCompletion19 = (_step19 = _iterator19.next()).done); _iteratorNormalCompletion19 = true) {
              var path = _step19.value;
              path.toggleInvertedColors();
            }
          } catch (err) {
            _didIteratorError19 = true;
            _iteratorError19 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion19 && _iterator19.return != null) {
                _iterator19.return();
              }
            } finally {
              if (_didIteratorError19) {
                throw _iteratorError19;
              }
            }
          }

          this.invertedColors = !this.invertedColors;
        }
      }, {
        key: "toggleDebugMode",
        value: function toggleDebugMode() {
          this.setDebugMode(!this.getDebugMode());
        }
      }, {
        key: "toggleFillMode",
        value: function toggleFillMode() {
          this.setFillMode(!this.getFillMode());
        }
      }]);

      return World;
    }();

    module.exports = World;
  }, {
    "./Defaults": 3,
    "./node_modules/rbush": 9,
    "./node_modules/rbush-knn": 8
  }],
  7: [function (require, module, exports) {
    (function (global, factory) {
      _typeof(exports) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.quickselect = factory();
    })(this, function () {
      'use strict';

      function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
      }

      function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) swap(arr, left, right);

          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;

            while (compare(arr[i], t) < 0) {
              i++;
            }

            while (compare(arr[j], t) > 0) {
              j--;
            }
          }

          if (compare(arr[left], t) === 0) swap(arr, left, j);else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
        }
      }

      function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }

      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }

      return quickselect;
    });
  }, {}],
  8: [function (require, module, exports) {
    'use strict';

    var Queue = require('tinyqueue');

    module.exports = knn;
    module.exports.default = knn;

    function knn(tree, x, y, n, predicate, maxDistance) {
      var node = tree.data,
          result = [],
          toBBox = tree.toBBox,
          i,
          child,
          dist,
          candidate;
      var queue = new Queue(null, compareDist);

      while (node) {
        for (i = 0; i < node.children.length; i++) {
          child = node.children[i];
          dist = boxDist(x, y, node.leaf ? toBBox(child) : child);

          if (!maxDistance || dist <= maxDistance) {
            queue.push({
              node: child,
              isItem: node.leaf,
              dist: dist
            });
          }
        }

        while (queue.length && queue.peek().isItem) {
          candidate = queue.pop().node;
          if (!predicate || predicate(candidate)) result.push(candidate);
          if (n && result.length === n) return result;
        }

        node = queue.pop();
        if (node) node = node.node;
      }

      return result;
    }

    function compareDist(a, b) {
      return a.dist - b.dist;
    }

    function boxDist(x, y, box) {
      var dx = axisDist(x, box.minX, box.maxX),
          dy = axisDist(y, box.minY, box.maxY);
      return dx * dx + dy * dy;
    }

    function axisDist(k, min, max) {
      return k < min ? min - k : k <= max ? 0 : k - max;
    }
  }, {
    "tinyqueue": 11
  }],
  9: [function (require, module, exports) {
    'use strict';

    module.exports = rbush;
    module.exports.default = rbush;

    var quickselect = require('quickselect');

    function rbush(maxEntries, format) {
      if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance

      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

      if (format) {
        this._initFormat(format);
      }

      this.clear();
    }

    rbush.prototype = {
      all: function all() {
        return this._all(this.data, []);
      },
      search: function search(bbox) {
        var node = this.data,
            result = [],
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return result;
        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
              if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return result;
      },
      collides: function collides(bbox) {
        var node = this.data,
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return false;
        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) return true;
              nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return false;
      },
      load: function load(data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
          for (var i = 0, len = data.length; i < len; i++) {
            this.insert(data[i]);
          }

          return this;
        } // recursively build the tree with the given data from scratch using OMT algorithm


        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
          // save as is if tree is empty
          this.data = node;
        } else if (this.data.height === node.height) {
          // split root if trees have the same height
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            // swap trees if inserted one is bigger
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          } // insert the small tree into the large tree at appropriate level


          this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
      },
      insert: function insert(item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
      },
      clear: function clear() {
        this.data = createNode([]);
        return this;
      },
      remove: function remove(item, equalsFn) {
        if (!item) return this;
        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i,
            parent,
            index,
            goingUp; // depth-first iterative tree traversal

        while (node || path.length) {
          if (!node) {
            // go up
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }

          if (node.leaf) {
            // check current node
            index = findItem(item, node.children, equalsFn);

            if (index !== -1) {
              // item found, remove the item and condense tree upwards
              node.children.splice(index, 1);
              path.push(node);

              this._condense(path);

              return this;
            }
          }

          if (!goingUp && !node.leaf && contains(node, bbox)) {
            // go down
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            // go right
            i++;
            node = parent.children[i];
            goingUp = false;
          } else node = null; // nothing found

        }

        return this;
      },
      toBBox: function toBBox(item) {
        return item;
      },
      compareMinX: compareNodeMinX,
      compareMinY: compareNodeMinY,
      toJSON: function toJSON() {
        return this.data;
      },
      fromJSON: function fromJSON(data) {
        this.data = data;
        return this;
      },
      _all: function _all(node, result) {
        var nodesToSearch = [];

        while (node) {
          if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);
          node = nodesToSearch.pop();
        }

        return result;
      },
      _build: function _build(items, left, right, height) {
        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
          // reached leaf level; return leaf
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }

        if (!height) {
          // target height of the bulk-loaded tree
          height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization

          M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height; // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i,
            j,
            right2,
            right3;
        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {
          right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);

          for (j = i; j <= right2; j += N2) {
            right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively

            node.children.push(this._build(items, j, right3, height - 1));
          }
        }

        calcBBox(node, this.toBBox);
        return node;
      },
      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {
        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) break;
          minArea = minEnlargement = Infinity;

          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            area = bboxArea(child);
            enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement

            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              // otherwise choose one with the smallest area
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }

          node = targetNode || node.children[0];
        }

        return node;
      },
      _insert: function _insert(item, level, isNode) {
        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too

        var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node


        node.children.push(item);
        extend(node, bbox); // split on node overflow; propagate upwards if necessary

        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);

            level--;
          } else break;
        } // adjust bboxes along the insertion path


        this._adjustParentBBoxes(bbox, insertPath, level);
      },
      // split overflowed node into two
      _split: function _split(insertPath, level) {
        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);
      },
      _splitRoot: function _splitRoot(node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      },
      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {
        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
          bbox1 = distBBox(node, 0, i, this.toBBox);
          bbox2 = distBBox(node, i, M, this.toBBox);
          overlap = intersectionArea(bbox1, bbox2);
          area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap

          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            // otherwise choose distribution with minimum area
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }

        return index;
      },
      // sorts node children by the best axis for split
      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY


        if (xMargin < yMargin) node.children.sort(compareMinX);
      },
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin: function _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i,
            child;

        for (i = m; i < M - m; i++) {
          child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
          child = node.children[i];
          extend(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }

        return margin;
      },
      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
        }
      },
      _condense: function _condense(path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else this.clear();
          } else calcBBox(path[i], this.toBBox);
        }
      },
      _initFormat: function _initFormat(format) {
        // data format (minX, minY, maxX, maxY accessors)
        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls
        var compareArr = ['return a', ' - b', ';'];
        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
        this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
      }
    };

    function findItem(item, items, equalsFn) {
      if (!equalsFn) return items.indexOf(item);

      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
      }

      return -1;
    } // calculate node's bbox from bboxes of its children


    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    } // min bounding rectangle of node children from k to p-1


    function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) destNode = createNode(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
    }

    function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
    }

    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }

    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }

    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }

    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }

    function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }

    function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX),
          minY = Math.max(a.minY, b.minY),
          maxX = Math.min(a.maxX, b.maxX),
          maxY = Math.min(a.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }

    function contains(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }

    function intersects(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }

    function createNode(children) {
      return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    } // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach


    function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right],
          mid;

      while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n) continue;
        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);
        stack.push(left, mid, mid, right);
      }
    }
  }, {
    "quickselect": 7
  }],
  10: [function (require, module, exports) {
    !function (t, r) {
      "object" == _typeof(exports) && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : r(t.svgpathdata = {});
    }(this, function (t) {
      "use strict";

      var r = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (t, r) {
        t.__proto__ = r;
      } || function (t, r) {
        for (var e in r) {
          r.hasOwnProperty(e) && (t[e] = r[e]);
        }
      };

      function e(t, e) {
        function a() {
          this.constructor = t;
        }

        r(t, e), t.prototype = null === e ? Object.create(e) : (a.prototype = e.prototype, new a());
      }

      function a(t, r) {
        var e = t[0],
            a = t[1];
        return [e * Math.cos(r) - a * Math.sin(r), e * Math.sin(r) + a * Math.cos(r)];
      }

      function n() {
        for (var t = [], r = 0; r < arguments.length; r++) {
          t[r] = arguments[r];
        }

        for (var e = 0; e < t.length; e++) {
          if ("number" != typeof t[e]) throw new Error("assertNumbers arguments[" + e + "] is not a number. " + _typeof(t[e]) + " == typeof " + t[e]);
        }

        return !0;
      }

      var i = Math.PI;

      function o(t, r, e) {
        t.lArcFlag = 0 === t.lArcFlag ? 0 : 1, t.sweepFlag = 0 === t.sweepFlag ? 0 : 1;
        var n = t.rX,
            o = t.rY,
            s = t.x,
            u = t.y;
        n = Math.abs(t.rX), o = Math.abs(t.rY);
        var h = a([(r - s) / 2, (e - u) / 2], -t.xRot / 180 * i),
            c = h[0],
            m = h[1],
            y = Math.pow(c, 2) / Math.pow(n, 2) + Math.pow(m, 2) / Math.pow(o, 2);
        1 < y && (n *= Math.sqrt(y), o *= Math.sqrt(y)), t.rX = n, t.rY = o;

        var p = Math.pow(n, 2) * Math.pow(m, 2) + Math.pow(o, 2) * Math.pow(c, 2),
            T = (t.lArcFlag !== t.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(n, 2) * Math.pow(o, 2) - p) / p)),
            O = n * m / o * T,
            _ = -o * c / n * T,
            f = a([O, _], t.xRot / 180 * i);

        t.cX = f[0] + (r + s) / 2, t.cY = f[1] + (e + u) / 2, t.phi1 = Math.atan2((m - _) / o, (c - O) / n), t.phi2 = Math.atan2((-m - _) / o, (-c - O) / n), 0 === t.sweepFlag && t.phi2 > t.phi1 && (t.phi2 -= 2 * i), 1 === t.sweepFlag && t.phi2 < t.phi1 && (t.phi2 += 2 * i), t.phi1 *= 180 / i, t.phi2 *= 180 / i;
      }

      function s(t, r, e) {
        n(t, r, e);
        var a = t * t + r * r - e * e;
        if (0 > a) return [];
        if (0 === a) return [[t * e / (t * t + r * r), r * e / (t * t + r * r)]];
        var i = Math.sqrt(a);
        return [[(t * e + r * i) / (t * t + r * r), (r * e - t * i) / (t * t + r * r)], [(t * e - r * i) / (t * t + r * r), (r * e + t * i) / (t * t + r * r)]];
      }

      var u = Math.PI / 180;

      function h(t, r, e) {
        return (1 - e) * t + e * r;
      }

      function c(t, r, e, a) {
        return t + Math.cos(a / 180 * i) * r + Math.sin(a / 180 * i) * e;
      }

      function m(t, r, e, a) {
        var n = r - t,
            i = e - r,
            o = 3 * n + 3 * (a - e) - 6 * i,
            s = 6 * (i - n),
            u = 3 * n;
        return Math.abs(o) < 1e-6 ? [-u / s] : function (t, r, e) {
          void 0 === e && (e = 1e-6);
          var a = t * t / 4 - r;
          if (a < -e) return [];
          if (a <= e) return [-t / 2];
          var n = Math.sqrt(a);
          return [-t / 2 - n, -t / 2 + n];
        }(s / o, u / o, 1e-6);
      }

      function y(t, r, e, a, n) {
        var i = 1 - n;
        return t * (i * i * i) + r * (3 * i * i * n) + e * (3 * i * n * n) + a * (n * n * n);
      }

      !function (t) {
        function r() {
          return p(function (t, r, e) {
            return t.relative && (void 0 !== t.x1 && (t.x1 += r), void 0 !== t.y1 && (t.y1 += e), void 0 !== t.x2 && (t.x2 += r), void 0 !== t.y2 && (t.y2 += e), void 0 !== t.x && (t.x += r), void 0 !== t.y && (t.y += e), t.relative = !1), t;
          });
        }

        function e() {
          var t = NaN,
              r = NaN,
              e = NaN,
              a = NaN;
          return p(function (n, i, o) {
            return n.type & l.SMOOTH_CURVE_TO && (n.type = l.CURVE_TO, t = isNaN(t) ? i : t, r = isNaN(r) ? o : r, n.x1 = n.relative ? i - t : 2 * i - t, n.y1 = n.relative ? o - r : 2 * o - r), n.type & l.CURVE_TO ? (t = n.relative ? i + n.x2 : n.x2, r = n.relative ? o + n.y2 : n.y2) : (t = NaN, r = NaN), n.type & l.SMOOTH_QUAD_TO && (n.type = l.QUAD_TO, e = isNaN(e) ? i : e, a = isNaN(a) ? o : a, n.x1 = n.relative ? i - e : 2 * i - e, n.y1 = n.relative ? o - a : 2 * o - a), n.type & l.QUAD_TO ? (e = n.relative ? i + n.x1 : n.x1, a = n.relative ? o + n.y1 : n.y1) : (e = NaN, a = NaN), n;
          });
        }

        function i() {
          var t = NaN,
              r = NaN;
          return p(function (e, a, n) {
            if (e.type & l.SMOOTH_QUAD_TO && (e.type = l.QUAD_TO, t = isNaN(t) ? a : t, r = isNaN(r) ? n : r, e.x1 = e.relative ? a - t : 2 * a - t, e.y1 = e.relative ? n - r : 2 * n - r), e.type & l.QUAD_TO) {
              t = e.relative ? a + e.x1 : e.x1, r = e.relative ? n + e.y1 : e.y1;
              var i = e.x1,
                  o = e.y1;
              e.type = l.CURVE_TO, e.x1 = ((e.relative ? 0 : a) + 2 * i) / 3, e.y1 = ((e.relative ? 0 : n) + 2 * o) / 3, e.x2 = (e.x + 2 * i) / 3, e.y2 = (e.y + 2 * o) / 3;
            } else t = NaN, r = NaN;

            return e;
          });
        }

        function p(t) {
          var r = 0,
              e = 0,
              a = NaN,
              n = NaN;
          return function (i) {
            if (isNaN(a) && !(i.type & l.MOVE_TO)) throw new Error("path must start with moveto");
            var o = t(i, r, e, a, n);
            return i.type & l.CLOSE_PATH && (r = a, e = n), void 0 !== i.x && (r = i.relative ? r + i.x : i.x), void 0 !== i.y && (e = i.relative ? e + i.y : i.y), i.type & l.MOVE_TO && (a = r, n = e), o;
          };
        }

        function T(t, r, e, a, i, o) {
          return n(t, r, e, a, i, o), p(function (n, s, u, h) {
            var c = n.x1,
                m = n.x2,
                y = n.relative && !isNaN(h),
                p = void 0 !== n.x ? n.x : y ? 0 : s,
                T = void 0 !== n.y ? n.y : y ? 0 : u;

            function O(t) {
              return t * t;
            }

            n.type & l.HORIZ_LINE_TO && 0 !== r && (n.type = l.LINE_TO, n.y = n.relative ? 0 : u), n.type & l.VERT_LINE_TO && 0 !== e && (n.type = l.LINE_TO, n.x = n.relative ? 0 : s), void 0 !== n.x && (n.x = n.x * t + T * e + (y ? 0 : i)), void 0 !== n.y && (n.y = p * r + n.y * a + (y ? 0 : o)), void 0 !== n.x1 && (n.x1 = n.x1 * t + n.y1 * e + (y ? 0 : i)), void 0 !== n.y1 && (n.y1 = c * r + n.y1 * a + (y ? 0 : o)), void 0 !== n.x2 && (n.x2 = n.x2 * t + n.y2 * e + (y ? 0 : i)), void 0 !== n.y2 && (n.y2 = m * r + n.y2 * a + (y ? 0 : o));

            var _ = t * a - r * e;

            if (void 0 !== n.xRot && (1 !== t || 0 !== r || 0 !== e || 1 !== a)) if (0 === _) delete n.rX, delete n.rY, delete n.xRot, delete n.lArcFlag, delete n.sweepFlag, n.type = l.LINE_TO;else {
              var f = n.xRot * Math.PI / 180,
                  v = Math.sin(f),
                  N = Math.cos(f),
                  E = 1 / O(n.rX),
                  d = 1 / O(n.rY),
                  A = O(N) * E + O(v) * d,
                  x = 2 * v * N * (E - d),
                  C = O(v) * E + O(N) * d,
                  M = A * a * a - x * r * a + C * r * r,
                  R = x * (t * a + r * e) - 2 * (A * e * a + C * t * r),
                  S = A * e * e - x * t * e + C * t * t,
                  I = (Math.atan2(R, M - S) + Math.PI) % Math.PI / 2,
                  g = Math.sin(I),
                  V = Math.cos(I);
              n.rX = Math.abs(_) / Math.sqrt(M * O(V) + R * g * V + S * O(g)), n.rY = Math.abs(_) / Math.sqrt(M * O(g) - R * g * V + S * O(V)), n.xRot = 180 * I / Math.PI;
            }
            return void 0 !== n.sweepFlag && 0 > _ && (n.sweepFlag = +!n.sweepFlag), n;
          });
        }

        function O() {
          return function (t) {
            var r = {};

            for (var e in t) {
              r[e] = t[e];
            }

            return r;
          };
        }

        t.ROUND = function (t) {
          function r(r) {
            return Math.round(r * t) / t;
          }

          return void 0 === t && (t = 1e13), n(t), function (t) {
            return void 0 !== t.x1 && (t.x1 = r(t.x1)), void 0 !== t.y1 && (t.y1 = r(t.y1)), void 0 !== t.x2 && (t.x2 = r(t.x2)), void 0 !== t.y2 && (t.y2 = r(t.y2)), void 0 !== t.x && (t.x = r(t.x)), void 0 !== t.y && (t.y = r(t.y)), t;
          };
        }, t.TO_ABS = r, t.TO_REL = function () {
          return p(function (t, r, e) {
            return t.relative || (void 0 !== t.x1 && (t.x1 -= r), void 0 !== t.y1 && (t.y1 -= e), void 0 !== t.x2 && (t.x2 -= r), void 0 !== t.y2 && (t.y2 -= e), void 0 !== t.x && (t.x -= r), void 0 !== t.y && (t.y -= e), t.relative = !0), t;
          });
        }, t.NORMALIZE_HVZ = function (t, r, e) {
          return void 0 === t && (t = !0), void 0 === r && (r = !0), void 0 === e && (e = !0), p(function (a, n, i, o, s) {
            if (isNaN(o) && !(a.type & l.MOVE_TO)) throw new Error("path must start with moveto");
            return r && a.type & l.HORIZ_LINE_TO && (a.type = l.LINE_TO, a.y = a.relative ? 0 : i), e && a.type & l.VERT_LINE_TO && (a.type = l.LINE_TO, a.x = a.relative ? 0 : n), t && a.type & l.CLOSE_PATH && (a.type = l.LINE_TO, a.x = a.relative ? o - n : o, a.y = a.relative ? s - i : s), a.type & l.ARC && (0 === a.rX || 0 === a.rY) && (a.type = l.LINE_TO, delete a.rX, delete a.rY, delete a.xRot, delete a.lArcFlag, delete a.sweepFlag), a;
          });
        }, t.NORMALIZE_ST = e, t.QT_TO_C = i, t.INFO = p, t.SANITIZE = function (t) {
          void 0 === t && (t = 0), n(t);
          var r = NaN,
              e = NaN,
              a = NaN,
              i = NaN;
          return p(function (n, o, s, u, h) {
            var c = Math.abs,
                m = !1,
                y = 0,
                p = 0;

            if (n.type & l.SMOOTH_CURVE_TO && (y = isNaN(r) ? 0 : o - r, p = isNaN(e) ? 0 : s - e), n.type & (l.CURVE_TO | l.SMOOTH_CURVE_TO) ? (r = n.relative ? o + n.x2 : n.x2, e = n.relative ? s + n.y2 : n.y2) : (r = NaN, e = NaN), n.type & l.SMOOTH_QUAD_TO ? (a = isNaN(a) ? o : 2 * o - a, i = isNaN(i) ? s : 2 * s - i) : n.type & l.QUAD_TO ? (a = n.relative ? o + n.x1 : n.x1, i = n.relative ? s + n.y1 : n.y2) : (a = NaN, i = NaN), n.type & l.LINE_COMMANDS || n.type & l.ARC && (0 === n.rX || 0 === n.rY || !n.lArcFlag) || n.type & l.CURVE_TO || n.type & l.SMOOTH_CURVE_TO || n.type & l.QUAD_TO || n.type & l.SMOOTH_QUAD_TO) {
              var T = void 0 === n.x ? 0 : n.relative ? n.x : n.x - o,
                  O = void 0 === n.y ? 0 : n.relative ? n.y : n.y - s;
              y = isNaN(a) ? void 0 === n.x1 ? y : n.relative ? n.x : n.x1 - o : a - o, p = isNaN(i) ? void 0 === n.y1 ? p : n.relative ? n.y : n.y1 - s : i - s;

              var _ = void 0 === n.x2 ? 0 : n.relative ? n.x : n.x2 - o,
                  f = void 0 === n.y2 ? 0 : n.relative ? n.y : n.y2 - s;

              c(T) <= t && c(O) <= t && c(y) <= t && c(p) <= t && c(_) <= t && c(f) <= t && (m = !0);
            }

            return n.type & l.CLOSE_PATH && c(o - u) <= t && c(s - h) <= t && (m = !0), m ? [] : n;
          });
        }, t.MATRIX = T, t.ROTATE = function (t, r, e) {
          void 0 === r && (r = 0), void 0 === e && (e = 0), n(t, r, e);
          var a = Math.sin(t),
              i = Math.cos(t);
          return T(i, a, -a, i, r - r * i + e * a, e - r * a - e * i);
        }, t.TRANSLATE = function (t, r) {
          return void 0 === r && (r = 0), n(t, r), T(1, 0, 0, 1, t, r);
        }, t.SCALE = function (t, r) {
          return void 0 === r && (r = t), n(t, r), T(t, 0, 0, r, 0, 0);
        }, t.SKEW_X = function (t) {
          return n(t), T(1, 0, Math.atan(t), 1, 0, 0);
        }, t.SKEW_Y = function (t) {
          return n(t), T(1, Math.atan(t), 0, 1, 0, 0);
        }, t.X_AXIS_SYMMETRY = function (t) {
          return void 0 === t && (t = 0), n(t), T(-1, 0, 0, 1, t, 0);
        }, t.Y_AXIS_SYMMETRY = function (t) {
          return void 0 === t && (t = 0), n(t), T(1, 0, 0, -1, 0, t);
        }, t.A_TO_C = function () {
          return p(function (t, r, e) {
            return l.ARC === t.type ? function (t, r, e) {
              var n, i, s, c;
              t.cX || o(t, r, e);

              for (var m = Math.min(t.phi1, t.phi2), y = Math.max(t.phi1, t.phi2) - m, p = Math.ceil(y / 90), T = new Array(p), O = r, _ = e, f = 0; f < p; f++) {
                var v = h(t.phi1, t.phi2, f / p),
                    N = h(t.phi1, t.phi2, (f + 1) / p),
                    E = N - v,
                    d = 4 / 3 * Math.tan(E * u / 4),
                    A = [Math.cos(v * u) - d * Math.sin(v * u), Math.sin(v * u) + d * Math.cos(v * u)],
                    x = A[0],
                    C = A[1],
                    M = [Math.cos(N * u), Math.sin(N * u)],
                    R = M[0],
                    S = M[1],
                    I = [R + d * Math.sin(N * u), S - d * Math.cos(N * u)],
                    g = I[0],
                    V = I[1];
                T[f] = {
                  relative: t.relative,
                  type: l.CURVE_TO
                };

                var L = function L(r, e) {
                  var n = a([r * t.rX, e * t.rY], t.xRot),
                      i = n[0],
                      o = n[1];
                  return [t.cX + i, t.cY + o];
                };

                n = L(x, C), T[f].x1 = n[0], T[f].y1 = n[1], i = L(g, V), T[f].x2 = i[0], T[f].y2 = i[1], s = L(R, S), T[f].x = s[0], T[f].y = s[1], t.relative && (T[f].x1 -= O, T[f].y1 -= _, T[f].x2 -= O, T[f].y2 -= _, T[f].x -= O, T[f].y -= _), O = (c = [T[f].x, T[f].y])[0], _ = c[1];
              }

              return T;
            }(t, t.relative ? 0 : r, t.relative ? 0 : e) : t;
          });
        }, t.ANNOTATE_ARCS = function () {
          return p(function (t, r, e) {
            return t.relative && (r = 0, e = 0), l.ARC === t.type && o(t, r, e), t;
          });
        }, t.CLONE = O, t.CALCULATE_BOUNDS = function () {
          var t = function t(_t) {
            var r = {};

            for (var e in _t) {
              r[e] = _t[e];
            }

            return r;
          },
              a = r(),
              n = i(),
              u = e(),
              h = p(function (r, e, i) {
            var p = u(n(a(t(r))));

            function T(t) {
              t > h.maxX && (h.maxX = t), t < h.minX && (h.minX = t);
            }

            function O(t) {
              t > h.maxY && (h.maxY = t), t < h.minY && (h.minY = t);
            }

            if (p.type & l.DRAWING_COMMANDS && (T(e), O(i)), p.type & l.HORIZ_LINE_TO && T(p.x), p.type & l.VERT_LINE_TO && O(p.y), p.type & l.LINE_TO && (T(p.x), O(p.y)), p.type & l.CURVE_TO) {
              T(p.x), O(p.y);

              for (var _ = 0, f = m(e, p.x1, p.x2, p.x); _ < f.length; _++) {
                0 < (U = f[_]) && 1 > U && T(y(e, p.x1, p.x2, p.x, U));
              }

              for (var v = 0, N = m(i, p.y1, p.y2, p.y); v < N.length; v++) {
                0 < (U = N[v]) && 1 > U && O(y(i, p.y1, p.y2, p.y, U));
              }
            }

            if (p.type & l.ARC) {
              T(p.x), O(p.y), o(p, e, i);

              for (var E = p.xRot / 180 * Math.PI, d = Math.cos(E) * p.rX, A = Math.sin(E) * p.rX, x = -Math.sin(E) * p.rY, C = Math.cos(E) * p.rY, M = p.phi1 < p.phi2 ? [p.phi1, p.phi2] : -180 > p.phi2 ? [p.phi2 + 360, p.phi1 + 360] : [p.phi2, p.phi1], R = M[0], S = M[1], I = function I(t) {
                var r = t[0],
                    e = t[1],
                    a = 180 * Math.atan2(e, r) / Math.PI;
                return a < R ? a + 360 : a;
              }, g = 0, V = s(x, -d, 0).map(I); g < V.length; g++) {
                (U = V[g]) > R && U < S && T(c(p.cX, d, x, U));
              }

              for (var L = 0, D = s(C, -A, 0).map(I); L < D.length; L++) {
                var U;
                (U = D[L]) > R && U < S && O(c(p.cY, A, C, U));
              }
            }

            return r;
          });

          return h.minX = 1 / 0, h.maxX = -1 / 0, h.minY = 1 / 0, h.maxY = -1 / 0, h;
        };
      }(t.SVGPathDataTransformer || (t.SVGPathDataTransformer = {}));

      var p,
          T,
          O = function () {
        function r() {}

        return r.prototype.round = function (r) {
          return this.transform(t.SVGPathDataTransformer.ROUND(r));
        }, r.prototype.toAbs = function () {
          return this.transform(t.SVGPathDataTransformer.TO_ABS());
        }, r.prototype.toRel = function () {
          return this.transform(t.SVGPathDataTransformer.TO_REL());
        }, r.prototype.normalizeHVZ = function (r, e, a) {
          return this.transform(t.SVGPathDataTransformer.NORMALIZE_HVZ(r, e, a));
        }, r.prototype.normalizeST = function () {
          return this.transform(t.SVGPathDataTransformer.NORMALIZE_ST());
        }, r.prototype.qtToC = function () {
          return this.transform(t.SVGPathDataTransformer.QT_TO_C());
        }, r.prototype.aToC = function () {
          return this.transform(t.SVGPathDataTransformer.A_TO_C());
        }, r.prototype.sanitize = function (r) {
          return this.transform(t.SVGPathDataTransformer.SANITIZE(r));
        }, r.prototype.translate = function (r, e) {
          return this.transform(t.SVGPathDataTransformer.TRANSLATE(r, e));
        }, r.prototype.scale = function (r, e) {
          return this.transform(t.SVGPathDataTransformer.SCALE(r, e));
        }, r.prototype.rotate = function (r, e, a) {
          return this.transform(t.SVGPathDataTransformer.ROTATE(r, e, a));
        }, r.prototype.matrix = function (r, e, a, n, i, o) {
          return this.transform(t.SVGPathDataTransformer.MATRIX(r, e, a, n, i, o));
        }, r.prototype.skewX = function (r) {
          return this.transform(t.SVGPathDataTransformer.SKEW_X(r));
        }, r.prototype.skewY = function (r) {
          return this.transform(t.SVGPathDataTransformer.SKEW_Y(r));
        }, r.prototype.xSymmetry = function (r) {
          return this.transform(t.SVGPathDataTransformer.X_AXIS_SYMMETRY(r));
        }, r.prototype.ySymmetry = function (r) {
          return this.transform(t.SVGPathDataTransformer.Y_AXIS_SYMMETRY(r));
        }, r.prototype.annotateArcs = function () {
          return this.transform(t.SVGPathDataTransformer.ANNOTATE_ARCS());
        }, r;
      }(),
          _ = function _(t) {
        return " " === t || "\t" === t || "\r" === t || "\n" === t;
      },
          f = function f(t) {
        return "0".charCodeAt(0) <= t.charCodeAt(0) && t.charCodeAt(0) <= "9".charCodeAt(0);
      },
          v = function (t) {
        function r() {
          var r = t.call(this) || this;
          return r.curNumber = "", r.curCommandType = -1, r.curCommandRelative = !1, r.canParseCommandOrComma = !0, r.curNumberHasExp = !1, r.curNumberHasExpDigits = !1, r.curNumberHasDecimal = !1, r.curArgs = [], r;
        }

        return e(r, t), r.prototype.finish = function (t) {
          if (void 0 === t && (t = []), this.parse(" ", t), 0 !== this.curArgs.length || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
          return t;
        }, r.prototype.parse = function (t, r) {
          var e = this;
          void 0 === r && (r = []);

          for (var a = function a(t) {
            r.push(t), e.curArgs.length = 0, e.canParseCommandOrComma = !0;
          }, n = 0; n < t.length; n++) {
            var i = t[n];
            if (f(i)) this.curNumber += i, this.curNumberHasExpDigits = this.curNumberHasExp;else if ("e" !== i && "E" !== i) {
              if ("-" !== i && "+" !== i || !this.curNumberHasExp || this.curNumberHasExpDigits) {
                if ("." !== i || this.curNumberHasExp || this.curNumberHasDecimal) {
                  if (this.curNumber && -1 !== this.curCommandType) {
                    var o = Number(this.curNumber);
                    if (isNaN(o)) throw new SyntaxError("Invalid number ending at " + n);
                    if (this.curCommandType === l.ARC) if (0 === this.curArgs.length || 1 === this.curArgs.length) {
                      if (0 > o) throw new SyntaxError('Expected positive number, got "' + o + '" at index "' + n + '"');
                    } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && "0" !== this.curNumber && "1" !== this.curNumber) throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + n + '"');
                    this.curArgs.push(o), this.curArgs.length === N[this.curCommandType] && (l.HORIZ_LINE_TO === this.curCommandType ? a({
                      type: l.HORIZ_LINE_TO,
                      relative: this.curCommandRelative,
                      x: o
                    }) : l.VERT_LINE_TO === this.curCommandType ? a({
                      type: l.VERT_LINE_TO,
                      relative: this.curCommandRelative,
                      y: o
                    }) : this.curCommandType === l.MOVE_TO || this.curCommandType === l.LINE_TO || this.curCommandType === l.SMOOTH_QUAD_TO ? (a({
                      type: this.curCommandType,
                      relative: this.curCommandRelative,
                      x: this.curArgs[0],
                      y: this.curArgs[1]
                    }), l.MOVE_TO === this.curCommandType && (this.curCommandType = l.LINE_TO)) : this.curCommandType === l.CURVE_TO ? a({
                      type: l.CURVE_TO,
                      relative: this.curCommandRelative,
                      x1: this.curArgs[0],
                      y1: this.curArgs[1],
                      x2: this.curArgs[2],
                      y2: this.curArgs[3],
                      x: this.curArgs[4],
                      y: this.curArgs[5]
                    }) : this.curCommandType === l.SMOOTH_CURVE_TO ? a({
                      type: l.SMOOTH_CURVE_TO,
                      relative: this.curCommandRelative,
                      x2: this.curArgs[0],
                      y2: this.curArgs[1],
                      x: this.curArgs[2],
                      y: this.curArgs[3]
                    }) : this.curCommandType === l.QUAD_TO ? a({
                      type: l.QUAD_TO,
                      relative: this.curCommandRelative,
                      x1: this.curArgs[0],
                      y1: this.curArgs[1],
                      x: this.curArgs[2],
                      y: this.curArgs[3]
                    }) : this.curCommandType === l.ARC && a({
                      type: l.ARC,
                      relative: this.curCommandRelative,
                      rX: this.curArgs[0],
                      rY: this.curArgs[1],
                      xRot: this.curArgs[2],
                      lArcFlag: this.curArgs[3],
                      sweepFlag: this.curArgs[4],
                      x: this.curArgs[5],
                      y: this.curArgs[6]
                    })), this.curNumber = "", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;
                  }

                  if (!_(i)) if ("," === i && this.canParseCommandOrComma) this.canParseCommandOrComma = !1;else if ("+" !== i && "-" !== i && "." !== i) {
                    if (0 !== this.curArgs.length) throw new SyntaxError("Unterminated command at index " + n + ".");
                    if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character "' + i + '" at index ' + n + ". Command cannot follow comma");
                    if (this.canParseCommandOrComma = !1, "z" !== i && "Z" !== i) {
                      if ("h" === i || "H" === i) this.curCommandType = l.HORIZ_LINE_TO, this.curCommandRelative = "h" === i;else if ("v" === i || "V" === i) this.curCommandType = l.VERT_LINE_TO, this.curCommandRelative = "v" === i;else if ("m" === i || "M" === i) this.curCommandType = l.MOVE_TO, this.curCommandRelative = "m" === i;else if ("l" === i || "L" === i) this.curCommandType = l.LINE_TO, this.curCommandRelative = "l" === i;else if ("c" === i || "C" === i) this.curCommandType = l.CURVE_TO, this.curCommandRelative = "c" === i;else if ("s" === i || "S" === i) this.curCommandType = l.SMOOTH_CURVE_TO, this.curCommandRelative = "s" === i;else if ("q" === i || "Q" === i) this.curCommandType = l.QUAD_TO, this.curCommandRelative = "q" === i;else if ("t" === i || "T" === i) this.curCommandType = l.SMOOTH_QUAD_TO, this.curCommandRelative = "t" === i;else {
                        if ("a" !== i && "A" !== i) throw new SyntaxError('Unexpected character "' + i + '" at index ' + n + ".");
                        this.curCommandType = l.ARC, this.curCommandRelative = "a" === i;
                      }
                    } else r.push({
                      type: l.CLOSE_PATH
                    }), this.canParseCommandOrComma = !0, this.curCommandType = -1;
                  } else this.curNumber = i, this.curNumberHasDecimal = "." === i;
                } else this.curNumber += i, this.curNumberHasDecimal = !0;
              } else this.curNumber += i;
            } else this.curNumber += i, this.curNumberHasExp = !0;
          }

          return r;
        }, r.prototype.transform = function (t) {
          return Object.create(this, {
            parse: {
              value: function value(r, e) {
                void 0 === e && (e = []);

                for (var a = 0, n = Object.getPrototypeOf(this).parse.call(this, r); a < n.length; a++) {
                  var i = n[a],
                      o = t(i);
                  Array.isArray(o) ? e.push.apply(e, o) : e.push(o);
                }

                return e;
              }
            }
          });
        }, r;
      }(O),
          l = function (r) {
        function a(t) {
          var e = r.call(this) || this;
          return e.commands = "string" == typeof t ? a.parse(t) : t, e;
        }

        return e(a, r), a.prototype.encode = function () {
          return a.encode(this.commands);
        }, a.prototype.getBounds = function () {
          var r = t.SVGPathDataTransformer.CALCULATE_BOUNDS();
          return this.transform(r), r;
        }, a.prototype.transform = function (t) {
          for (var r = [], e = 0, a = this.commands; e < a.length; e++) {
            var n = t(a[e]);
            Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
          }

          return this.commands = r, this;
        }, a.encode = function (t) {
          return d(t);
        }, a.parse = function (t) {
          var r = new v(),
              e = [];
          return r.parse(t, e), r.finish(e), e;
        }, a.CLOSE_PATH = 1, a.MOVE_TO = 2, a.HORIZ_LINE_TO = 4, a.VERT_LINE_TO = 8, a.LINE_TO = 16, a.CURVE_TO = 32, a.SMOOTH_CURVE_TO = 64, a.QUAD_TO = 128, a.SMOOTH_QUAD_TO = 256, a.ARC = 512, a.LINE_COMMANDS = a.LINE_TO | a.HORIZ_LINE_TO | a.VERT_LINE_TO, a.DRAWING_COMMANDS = a.HORIZ_LINE_TO | a.VERT_LINE_TO | a.LINE_TO | a.CURVE_TO | a.SMOOTH_CURVE_TO | a.QUAD_TO | a.SMOOTH_QUAD_TO | a.ARC, a;
      }(O),
          N = ((p = {})[l.MOVE_TO] = 2, p[l.LINE_TO] = 2, p[l.HORIZ_LINE_TO] = 1, p[l.VERT_LINE_TO] = 1, p[l.CLOSE_PATH] = 0, p[l.QUAD_TO] = 4, p[l.SMOOTH_QUAD_TO] = 2, p[l.CURVE_TO] = 6, p[l.SMOOTH_CURVE_TO] = 4, p[l.ARC] = 7, p),
          E = " ";

      function d(t) {
        var r = "";
        Array.isArray(t) || (t = [t]);

        for (var e = 0; e < t.length; e++) {
          var a = t[e];
          if (a.type === l.CLOSE_PATH) r += "z";else if (a.type === l.HORIZ_LINE_TO) r += (a.relative ? "h" : "H") + a.x;else if (a.type === l.VERT_LINE_TO) r += (a.relative ? "v" : "V") + a.y;else if (a.type === l.MOVE_TO) r += (a.relative ? "m" : "M") + a.x + E + a.y;else if (a.type === l.LINE_TO) r += (a.relative ? "l" : "L") + a.x + E + a.y;else if (a.type === l.CURVE_TO) r += (a.relative ? "c" : "C") + a.x1 + E + a.y1 + E + a.x2 + E + a.y2 + E + a.x + E + a.y;else if (a.type === l.SMOOTH_CURVE_TO) r += (a.relative ? "s" : "S") + a.x2 + E + a.y2 + E + a.x + E + a.y;else if (a.type === l.QUAD_TO) r += (a.relative ? "q" : "Q") + a.x1 + E + a.y1 + E + a.x + E + a.y;else if (a.type === l.SMOOTH_QUAD_TO) r += (a.relative ? "t" : "T") + a.x + E + a.y;else {
            if (a.type !== l.ARC) throw new Error('Unexpected command type "' + a.type + '" at index ' + e + ".");
            r += (a.relative ? "a" : "A") + a.rX + E + a.rY + E + a.xRot + E + +a.lArcFlag + E + +a.sweepFlag + E + a.x + E + a.y;
          }
        }

        return r;
      }

      var A = function (r) {
        function a(t) {
          var e = r.call(this) || this;
          return e.commands = "string" == typeof t ? a.parse(t) : t, e;
        }

        return e(a, r), a.prototype.encode = function () {
          return a.encode(this.commands);
        }, a.prototype.getBounds = function () {
          var r = t.SVGPathDataTransformer.CALCULATE_BOUNDS();
          return this.transform(r), r;
        }, a.prototype.transform = function (t) {
          for (var r = [], e = 0, a = this.commands; e < a.length; e++) {
            var n = t(a[e]);
            Array.isArray(n) ? r.push.apply(r, n) : r.push(n);
          }

          return this.commands = r, this;
        }, a.encode = function (t) {
          return d(t);
        }, a.parse = function (t) {
          var r = new v(),
              e = [];
          return r.parse(t, e), r.finish(e), e;
        }, a.CLOSE_PATH = 1, a.MOVE_TO = 2, a.HORIZ_LINE_TO = 4, a.VERT_LINE_TO = 8, a.LINE_TO = 16, a.CURVE_TO = 32, a.SMOOTH_CURVE_TO = 64, a.QUAD_TO = 128, a.SMOOTH_QUAD_TO = 256, a.ARC = 512, a.LINE_COMMANDS = a.LINE_TO | a.HORIZ_LINE_TO | a.VERT_LINE_TO, a.DRAWING_COMMANDS = a.HORIZ_LINE_TO | a.VERT_LINE_TO | a.LINE_TO | a.CURVE_TO | a.SMOOTH_CURVE_TO | a.QUAD_TO | a.SMOOTH_QUAD_TO | a.ARC, a;
      }(O),
          x = ((T = {})[A.MOVE_TO] = 2, T[A.LINE_TO] = 2, T[A.HORIZ_LINE_TO] = 1, T[A.VERT_LINE_TO] = 1, T[A.CLOSE_PATH] = 0, T[A.QUAD_TO] = 4, T[A.SMOOTH_QUAD_TO] = 2, T[A.CURVE_TO] = 6, T[A.SMOOTH_CURVE_TO] = 4, T[A.ARC] = 7, T);

      t.SVGPathData = A, t.COMMAND_ARG_COUNTS = x, t.encodeSVGPath = d, t.SVGPathDataParser = v, Object.defineProperty(t, "__esModule", {
        value: !0
      });
    });
  }, {}],
  11: [function (require, module, exports) {
    'use strict';

    module.exports = TinyQueue;
    module.exports.default = TinyQueue;

    function TinyQueue(data, compare) {
      if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);
      this.data = data || [];
      this.length = this.data.length;
      this.compare = compare || defaultCompare;

      if (this.length > 0) {
        for (var i = (this.length >> 1) - 1; i >= 0; i--) {
          this._down(i);
        }
      }
    }

    function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }

    TinyQueue.prototype = {
      push: function push(item) {
        this.data.push(item);
        this.length++;

        this._up(this.length - 1);
      },
      pop: function pop() {
        if (this.length === 0) return undefined;
        var top = this.data[0];
        this.length--;

        if (this.length > 0) {
          this.data[0] = this.data[this.length];

          this._down(0);
        }

        this.data.pop();
        return top;
      },
      peek: function peek() {
        return this.data[0];
      },
      _up: function _up(pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];

        while (pos > 0) {
          var parent = pos - 1 >> 1;
          var current = data[parent];
          if (compare(item, current) >= 0) break;
          data[pos] = current;
          pos = parent;
        }

        data[pos] = item;
      },
      _down: function _down(pos) {
        var data = this.data;
        var compare = this.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];

        while (pos < halfLength) {
          var left = (pos << 1) + 1;
          var right = left + 1;
          var best = data[left];

          if (right < this.length && compare(data[right], best) < 0) {
            left = right;
            best = data[right];
          }

          if (compare(best, item) >= 0) break;
          data[pos] = best;
          pos = left;
        }

        data[pos] = item;
      }
    };
  }, {}],
  12: [function (require, module, exports) {
    ;

    (function inject(clean, precision, undef) {
      var isArray = function isArray(a) {
        return Object.prototype.toString.call(a) === "[object Array]";
      };

      var defined = function defined(a) {
        return a !== undef;
      };

      function Vec2(x, y) {
        if (!(this instanceof Vec2)) {
          return new Vec2(x, y);
        }

        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else if ('object' === _typeof(x) && x) {
          y = x.y;
          x = x.x;
        }

        this.x = Vec2.clean(x || 0);
        this.y = Vec2.clean(y || 0);
      }

      Vec2.prototype = {
        change: function change(fn) {
          if (typeof fn === 'function') {
            if (this.observers) {
              this.observers.push(fn);
            } else {
              this.observers = [fn];
            }
          } else if (this.observers && this.observers.length) {
            for (var i = this.observers.length - 1; i >= 0; i--) {
              this.observers[i](this, fn);
            }
          }

          return this;
        },
        ignore: function ignore(fn) {
          if (this.observers) {
            if (!fn) {
              this.observers = [];
            } else {
              var o = this.observers,
                  l = o.length;

              while (l--) {
                o[l] === fn && o.splice(l, 1);
              }
            }
          }

          return this;
        },
        // set x and y
        set: function set(x, y, notify) {
          if ('number' != typeof x) {
            notify = y;
            y = x.y;
            x = x.x;
          }

          if (this.x === x && this.y === y) {
            return this;
          }

          var orig = null;

          if (notify !== false && this.observers && this.observers.length) {
            orig = this.clone();
          }

          this.x = Vec2.clean(x);
          this.y = Vec2.clean(y);

          if (notify !== false) {
            return this.change(orig);
          }
        },
        // reset x and y to zero
        zero: function zero() {
          return this.set(0, 0);
        },
        // return a new vector with the same component values
        // as this one
        clone: function clone() {
          return new this.constructor(this.x, this.y);
        },
        // negate the values of this vector
        negate: function negate(returnNew) {
          if (returnNew) {
            return new this.constructor(-this.x, -this.y);
          } else {
            return this.set(-this.x, -this.y);
          }
        },
        // Add the incoming `vec2` vector to this vector
        add: function add(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          }

          x += this.x;
          y += this.y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            // Return a new vector if `returnNew` is truthy
            return new this.constructor(x, y);
          }
        },
        // Subtract the incoming `vec2` from this vector
        subtract: function subtract(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          }

          x = this.x - x;
          y = this.y - y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            // Return a new vector if `returnNew` is truthy
            return new this.constructor(x, y);
          }
        },
        // Multiply this vector by the incoming `vec2`
        multiply: function multiply(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          } else if (typeof y != 'number') {
            returnNew = y;
            y = x;
          }

          x *= this.x;
          y *= this.y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            return new this.constructor(x, y);
          }
        },
        // Rotate this vector. Accepts a `Rotation` or angle in radians.
        //
        // Passing a truthy `inverse` will cause the rotation to
        // be reversed.
        //
        // If `returnNew` is truthy, a new
        // `Vec2` will be created with the values resulting from
        // the rotation. Otherwise the rotation will be applied
        // to this vector directly, and this vector will be returned.
        rotate: function rotate(r, inverse, returnNew) {
          var x = this.x,
              y = this.y,
              cos = Math.cos(r),
              sin = Math.sin(r),
              rx,
              ry;
          inverse = inverse ? -1 : 1;
          rx = cos * x - inverse * sin * y;
          ry = inverse * sin * x + cos * y;

          if (returnNew) {
            return new this.constructor(rx, ry);
          } else {
            return this.set(rx, ry);
          }
        },
        // Calculate the length of this vector
        length: function length() {
          var x = this.x,
              y = this.y;
          return Math.sqrt(x * x + y * y);
        },
        // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).
        lengthSquared: function lengthSquared() {
          var x = this.x,
              y = this.y;
          return x * x + y * y;
        },
        // Return the distance betwen this `Vec2` and the incoming vec2 vector
        // and return a scalar
        distance: function distance(vec2) {
          var x = this.x - vec2.x;
          var y = this.y - vec2.y;
          return Math.sqrt(x * x + y * y);
        },
        // Given Array of Vec2, find closest to this Vec2.
        nearest: function nearest(others) {
          var shortestDistance = Number.MAX_VALUE,
              nearest = null,
              currentDistance;

          for (var i = others.length - 1; i >= 0; i--) {
            currentDistance = this.distance(others[i]);

            if (currentDistance <= shortestDistance) {
              shortestDistance = currentDistance;
              nearest = others[i];
            }
          }

          return nearest;
        },
        // Convert this vector into a unit vector.
        // Returns the length.
        normalize: function normalize(returnNew) {
          var length = this.length(); // Collect a ratio to shrink the x and y coords

          var invertedLength = length < Number.MIN_VALUE ? 0 : 1 / length;

          if (!returnNew) {
            // Convert the coords to be greater than zero
            // but smaller than or equal to 1.0
            return this.set(this.x * invertedLength, this.y * invertedLength);
          } else {
            return new this.constructor(this.x * invertedLength, this.y * invertedLength);
          }
        },
        // Determine if another `Vec2`'s components match this one's
        // also accepts 2 scalars
        equal: function equal(v, w) {
          if (typeof v != 'number') {
            if (isArray(v)) {
              w = v[1];
              v = v[0];
            } else {
              w = v.y;
              v = v.x;
            }
          }

          return Vec2.clean(v) === this.x && Vec2.clean(w) === this.y;
        },
        // Return a new `Vec2` that contains the absolute value of
        // each of this vector's parts
        abs: function abs(returnNew) {
          var x = Math.abs(this.x),
              y = Math.abs(this.y);

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Return a new `Vec2` consisting of the smallest values
        // from this vector and the incoming
        //
        // When returnNew is truthy, a new `Vec2` will be returned
        // otherwise the minimum values in either this or `v` will
        // be applied to this vector.
        min: function min(v, returnNew) {
          var tx = this.x,
              ty = this.y,
              vx = v.x,
              vy = v.y,
              x = tx < vx ? tx : vx,
              y = ty < vy ? ty : vy;

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Return a new `Vec2` consisting of the largest values
        // from this vector and the incoming
        //
        // When returnNew is truthy, a new `Vec2` will be returned
        // otherwise the minimum values in either this or `v` will
        // be applied to this vector.
        max: function max(v, returnNew) {
          var tx = this.x,
              ty = this.y,
              vx = v.x,
              vy = v.y,
              x = tx > vx ? tx : vx,
              y = ty > vy ? ty : vy;

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Clamp values into a range.
        // If this vector's values are lower than the `low`'s
        // values, then raise them.  If they are higher than
        // `high`'s then lower them.
        //
        // Passing returnNew as true will cause a new Vec2 to be
        // returned.  Otherwise, this vector's values will be clamped
        clamp: function clamp(low, high, returnNew) {
          var ret = this.min(high, true).max(low);

          if (returnNew) {
            return ret;
          } else {
            return this.set(ret.x, ret.y);
          }
        },
        // Perform linear interpolation between two vectors
        // amount is a decimal between 0 and 1
        lerp: function lerp(vec, amount, returnNew) {
          return this.add(vec.subtract(this, true).multiply(amount), returnNew);
        },
        // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
        skew: function skew(returnNew) {
          if (!returnNew) {
            return this.set(-this.y, this.x);
          } else {
            return new this.constructor(-this.y, this.x);
          }
        },
        // calculate the dot product between
        // this vector and the incoming
        dot: function dot(b) {
          return Vec2.clean(this.x * b.x + b.y * this.y);
        },
        // calculate the perpendicular dot product between
        // this vector and the incoming
        perpDot: function perpDot(b) {
          return Vec2.clean(this.x * b.y - this.y * b.x);
        },
        // Determine the angle between two vec2s
        angleTo: function angleTo(vec) {
          return Math.atan2(this.perpDot(vec), this.dot(vec));
        },
        // Divide this vector's components by a scalar
        divide: function divide(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          } else if (typeof y != 'number') {
            returnNew = y;
            y = x;
          }

          if (x === 0 || y === 0) {
            throw new Error('division by zero');
          }

          if (isNaN(x) || isNaN(y)) {
            throw new Error('NaN detected');
          }

          if (returnNew) {
            return new this.constructor(this.x / x, this.y / y);
          }

          return this.set(this.x / x, this.y / y);
        },
        isPointOnLine: function isPointOnLine(start, end) {
          return (start.y - this.y) * (start.x - end.x) === (start.y - end.y) * (start.x - this.x);
        },
        toArray: function toArray() {
          return [this.x, this.y];
        },
        fromArray: function fromArray(array) {
          return this.set(array[0], array[1]);
        },
        toJSON: function toJSON() {
          return {
            x: this.x,
            y: this.y
          };
        },
        toString: function toString() {
          return '(' + this.x + ', ' + this.y + ')';
        },
        constructor: Vec2
      };

      Vec2.fromArray = function (array, ctor) {
        return new (ctor || Vec2)(array[0], array[1]);
      }; // Floating point stability


      Vec2.precision = precision || 8;
      var p = Math.pow(10, Vec2.precision);

      Vec2.clean = clean || function (val) {
        if (isNaN(val)) {
          throw new Error('NaN detected');
        }

        if (!isFinite(val)) {
          throw new Error('Infinity detected');
        }

        if (Math.round(val) === val) {
          return val;
        }

        return Math.round(val * p) / p;
      };

      Vec2.inject = inject;

      if (!clean) {
        Vec2.fast = inject(function (k) {
          return k;
        }); // Expose, but also allow creating a fresh Vec2 subclass.

        if (typeof module !== 'undefined' && _typeof(module.exports) == 'object') {
          module.exports = Vec2;
        } else {
          window.Vec2 = window.Vec2 || Vec2;
        }
      }

      return Vec2;
    })();
  }, {}]
}, {}, [2]);