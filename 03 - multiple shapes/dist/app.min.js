"use strict";

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

(function () {
  function r(e, n, t) {
    function o(i, f) {
      if (!n[i]) {
        if (!e[i]) {
          var c = "function" == typeof require && require;
          if (!f && c) return c(i, !0);
          if (u) return u(i, !0);
          var a = new Error("Cannot find module '" + i + "'");
          throw a.code = "MODULE_NOT_FOUND", a;
        }

        var p = n[i] = {
          exports: {}
        };
        e[i][0].call(p.exports, function (r) {
          var n = e[i][1][r];
          return o(n || r);
        }, p, p.exports, r, e, n, t);
      }

      return n[i].exports;
    }

    for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
      o(t[i]);
    }

    return o;
  }

  return r;
})()({
  1: [function (require, module, exports) {
    module.exports = {
      SeedRadius: 100,
      MinDistance: 1,
      MaxDistance: 5,
      RepulsionRadius: 10,
      MaxVelocity: .1,
      AttractionForce: .2,
      RepulsionForce: .6,
      AlignmentForce: .55,
      ScreenPadding: 20,
      MaxNodes: 10000,
      NodeInjectionInterval: 100,
      DrawNodes: false,
      TraceMode: false,
      InvertedColors: false,
      DebugMode: false,
      FillMode: false,
      BrownianMotionRange: .01
    };
  }, {}],
  2: [function (require, module, exports) {
    var Node = require('../../core/Node'),
        Path = require('../../core/Path'),
        World = require('../../core/World'),
        Settings = require('./Settings');

    var world;
    /*
    =============================================================================
      Main sketch
    =============================================================================
    */

    var sketch = function sketch(p5) {
      // Setup -------------------------------------------------------------
      p5.setup = function () {
        p5.createCanvas(window.innerWidth, window.innerHeight);
        p5.colorMode(p5.HSB, 255); // Set up and start the simulation

        world = new World(p5, undefined, Settings); // Create random paths

        restartWorld();
      }; // Draw ---------------------------------------------------------------


      p5.draw = function () {
        world.iterate();
        world.draw();
      }; // Create any generalized equilateral polygon -------------------------


      function createPolygon(xOffset, yOffset, nodeCount, radius) {
        var rotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var nodes = [];

        for (var i = 0; i < nodeCount; i++) {
          var angle = 2 * Math.PI * i / nodeCount + p5.radians(rotation);
          var nodeX = Math.floor(radius * Math.cos(angle));
          var nodeY = Math.floor(radius * Math.sin(angle));
          nodes.push(new Node(p5, window.innerWidth / 2 + xOffset + nodeX, window.innerHeight / 2 + yOffset + nodeY, false, Settings));
        }

        return nodes;
      } // Create nodes in a circle -------------------------------------------
      // Remember a circle on a computer is just a polygon with many sides!


      function createCircle(xOffset, yOffset, radius) {
        return createPolygon(xOffset, yOffset, 60, radius);
      } // Create three nodes to form an equilateral triangle -----------------


      function createTriangle(xOffset, yOffset, radius, rotation) {
        return createPolygon(xOffset, yOffset, 3, radius, rotation);
      } // Create four nodes to form a square ---------------------------------


      function createSquare(xOffset, yOffset, radius, rotation) {
        return createPolygon(xOffset, yOffset, 4, radius, rotation);
      } // Restart the simulation with a selected path type -------------------


      function restartWorld() {
        world.clearPaths(); // Create a circle

        world.addPath(new Path(p5, createCircle(-window.innerWidth / 6, 0, 150), true, Settings)); // Create a triangle

        world.addPath(new Path(p5, createTriangle(0, 0, 150, 30), true, Settings)); // Create a square

        world.addPath(new Path(p5, createSquare(window.innerWidth / 6, 0, 150, 45), true, Settings)); // Draw the first frame, then pause

        world.drawBackground();
        world.draw();
        world.pause(); // Restart simulation after 1s

        setTimeout(function () {
          world.unpause();
        }, 1000);
      }
      /*
      =============================================================================
        Key handler
      =============================================================================
      */


      p5.keyReleased = function () {
        switch (p5.key) {
          // Toggle trace mode with 't'
          case 't':
            world.toggleTraceMode();
            break;
          // Toggle drawing of nodes with 'n'

          case 'n':
            world.setDrawNodes(!world.getDrawNodes());
            break;
          // Reset simulation with current parameters with 'r'

          case 'r':
            restartWorld();
            break;
          // Toggle pause with Space

          case ' ':
            world.paused = !world.paused;
            break;
          // Invert colors with 'i'

          case 'i':
            world.toggleInvertedColors();
            world.drawBackground();
            break;
          // Toggle debug mode with 'd'

          case 'd':
            world.toggleDebugMode();
            break;
          // Toggle fill for all shapes with 'f'

          case 'f':
            world.toggleFillMode();
            break;
          // Export SVG with 's'
        }
      };
    }; // Launch the sketch using p5js in instantiated mode


    new p5(sketch);
  }, {
    "../../core/Node": 4,
    "../../core/Path": 5,
    "../../core/World": 6,
    "./Settings": 1
  }],
  3: [function (require, module, exports) {
    module.exports = {
      MinDistance: 20,
      // injection, attraction
      MaxDistance: 30,
      // split
      RepulsionRadius: 20,
      MaxVelocity: .1,
      Acceleration: .1,
      AttractionForce: .001,
      RepulsionForce: 500,
      AlignmentForce: .001,
      ScreenPadding: 20,
      MaxNodes: 3000,
      NodeInjectionInterval: 100,
      DrawNodes: false,
      TraceMode: false,
      UseBrownianMotion: false,
      BrownianMotionRange: 0.01
    };
  }, {}],
  4: [function (require, module, exports) {
    var Vec2 = require('./node_modules/vec2'),
        Defaults = require('./Defaults');
    /*
    =============================================================================
      Node class
    
      A Node is a single point on the canvas whose only job is to manage
      it's position and movement towards new position. 
    =============================================================================
    */


    var Node =
    /*#__PURE__*/
    function (_Vec) {
      _inherits(Node, _Vec);

      function Node(p5, x, y) {
        var _this;

        var isFixed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var settings = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Defaults;

        _classCallCheck(this, Node);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(Node).call(this, x, y));
        _this.p5 = p5;
        _this.isFixed = isFixed;
        _this.settings = settings;
        _this.velocity = 0;
        _this.nextPosition = new Vec2(x, y);
        return _this;
      }

      _createClass(Node, [{
        key: "iterate",
        value: function iterate() {
          if (!this.isFixed) {
            this.x = this.p5.lerp(this.x, this.nextPosition.x, this.settings.MaxVelocity);
            this.y = this.p5.lerp(this.y, this.nextPosition.y, this.settings.MaxVelocity);
          }
        }
      }, {
        key: "draw",
        value: function draw() {
          if (this.isFixed) {
            this.p5.ellipse(this.x, this.y, 20);
          } else {
            this.p5.ellipse(this.x, this.y, 5);
          }
        }
      }]);

      return Node;
    }(Vec2);

    module.exports = Node;
  }, {
    "./Defaults": 3,
    "./node_modules/vec2": 11
  }],
  5: [function (require, module, exports) {
    var knn = require('./node_modules/rbush-knn');

    Node = require('./Node');
    /*
    =============================================================================
      Path class
    
      A Path manages a set of Nodes in a continuous, ordered
      data structure (an Array). 
    =============================================================================
    */

    var Path =
    /*#__PURE__*/
    function () {
      function Path(p5, nodes) {
        var isClosed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Defaults;

        _classCallCheck(this, Path);

        this.p5 = p5;
        this.nodes = nodes;
        this.isClosed = isClosed;
        this.settings = settings;
        this.injectionMode = "RANDOM";
        this.lastNodeInjectTime = 0;
        this.drawNodes = this.settings.DrawNodes;
        this.invertedColors = this.settings.InvertedColors;
        this.traceMode = this.settings.TraceMode;
        this.debugMode = this.settings.DebugMode;
        this.fillMode = this.settings.FillMode;
        this.useBrownianMotion = this.settings.UseBrownianMotion;
      } //------------------------------------------------------------------
      //  Iterate
      //  =======
      //  Run a single 'tick' of the simulation 
      //-----------------------------------------------------------------


      _createClass(Path, [{
        key: "iterate",
        value: function iterate(tree) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.nodes.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var _step$value = _slicedToArray(_step.value, 2),
                  index = _step$value[0],
                  node = _step$value[1];

              // Apply Brownian motion to realistically 'jiggle' nodes
              if (this.useBrownianMotion) {
                this.applyBrownianMotion(index);
              } // Move towards neighbors (attraction), if there is space to move


              this.applyAttraction(index); // Move away from any nodes that are too close (repulsion)

              this.applyRepulsion(index, tree); // Align with neighbors

              this.applyAlignment(index); // Constrain to the screen

              this.avoidWalls(index); // Move towards next position

              node.iterate();
            } // Split any edges that have become too long

          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this.splitEdges(); // Remove any nodes that are too close to other nodes

          this.pruneNodes(); // Inject a new node to introduce asymmetry every so often

          if (this.p5.millis() - this.lastNodeInjectTime >= this.settings.NodeInjectionInterval && this.nodes.length < this.settings.MaxNodes) {
            this.injectNode();
            this.lastNodeInjectTime = this.p5.millis();
          }
        } //---------------------------------------------------------------------
        //  Brownian motion
        //  ===============
        //  Simulate the random

      }, {
        key: "applyBrownianMotion",
        value: function applyBrownianMotion(index) {
          this.nodes[index].x += this.p5.random(-this.settings.BrownianMotionRange / 2, this.settings.BrownianMotionRange / 2);
          this.nodes[index].y += this.p5.random(-this.settings.BrownianMotionRange / 2, this.settings.BrownianMotionRange / 2);
        } //---------------------------------------------------------------------
        //  Attraction
        //  ==========
        //  Move the referenced node closer to it's connected neighbor nodes
        //---------------------------------------------------------------------

      }, {
        key: "applyAttraction",
        value: function applyAttraction(index) {
          var distance;
          var connectedNodes = this.getConnectedNodes(index); // Move towards next node, if there is one

          if (connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && !this.nodes[index].isFixed) {
            distance = this.nodes[index].distance(connectedNodes.nextNode);

            if (distance > this.settings.MinDistance) {
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, connectedNodes.nextNode.x, this.settings.AttractionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, connectedNodes.nextNode.y, this.settings.AttractionForce);
            }
          } // Move towards previous node, if there is one


          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && !this.nodes[index].isFixed) {
            distance = this.nodes[index].distance(connectedNodes.previousNode);

            if (distance > this.settings.MinDistance) {
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, connectedNodes.previousNode.x, this.settings.AttractionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, connectedNodes.previousNode.y, this.settings.AttractionForce);
            }
          }
        } //------------------------------------------------------------------------
        //  Repulsion
        //  =========
        //  Move the referenced node away from all nearby nodes within a radius
        //------------------------------------------------------------------------

      }, {
        key: "applyRepulsion",
        value: function applyRepulsion(index, tree) {
          // Perform knn search to find all neighbors within certain radius
          var neighbors = knn(tree, this.nodes[index].x, this.nodes[index].y, undefined, undefined, this.settings.RepulsionRadius * this.settings.RepulsionRadius); // radius must be squared as per https://github.com/mourner/rbush-knn/issues/13
          // Move this node away from all nearby neighbors
          // TODO: Make this proportional to distance?

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = neighbors[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var node = _step2.value;
              this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].x, node.x, -this.settings.RepulsionForce);
              this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].y, node.y, -this.settings.RepulsionForce);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        } //-------------------------------------------------------------
        //  Alignment
        //  =========
        //  Move the referenced node closer to the midpoint of it's
        //  neighbor connected nodes to minimize curvature
        //-------------------------------------------------------------

      }, {
        key: "applyAlignment",
        value: function applyAlignment(index) {
          var connectedNodes = this.getConnectedNodes(index);

          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && !this.nodes[index].isFixed) {
            // Find the midpoint between the neighbors of this node
            var midpoint = this.getMidpointNode(connectedNodes.previousNode, connectedNodes.nextNode); // Move this point towards this midpoint

            this.nodes[index].nextPosition.x = this.p5.lerp(this.nodes[index].nextPosition.x, midpoint.x, this.settings.AlignmentForce);
            this.nodes[index].nextPosition.y = this.p5.lerp(this.nodes[index].nextPosition.y, midpoint.y, this.settings.AlignmentForce);
          }
        } //--------------------------------------------------------------
        //  Split edges
        //  ===========
        //  Search for long edges, then inject a new node when found
        //--------------------------------------------------------------

      }, {
        key: "splitEdges",
        value: function splitEdges() {
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = this.nodes.entries()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _step3$value = _slicedToArray(_step3.value, 2),
                  index = _step3$value[0],
                  node = _step3$value[1];

              var connectedNodes = this.getConnectedNodes(index);

              if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && node.distance(connectedNodes.previousNode) >= this.settings.MaxDistance && this.nodes.length < this.settings.MaxNodes) {
                var midpointNode = this.getMidpointNode(node, connectedNodes.previousNode); // Inject the new midpoint node into the global list

                if (index == 0) {
                  this.nodes.splice(this.nodes.length, 0, midpointNode);
                } else {
                  this.nodes.splice(index, 0, midpointNode);
                }
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
        } //------------------------------------------------------------
        //  Prune nodes
        //  ===========
        //  Remove nodes when they are too close to their neighbors
        //------------------------------------------------------------

      }, {
        key: "pruneNodes",
        value: function pruneNodes() {
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = this.nodes.entries()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _step4$value = _slicedToArray(_step4.value, 2),
                  index = _step4$value[0],
                  node = _step4$value[1];

              var connectedNodes = this.getConnectedNodes(index);

              if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && node.distance(connectedNodes.previousNode) < this.settings.MinDistance) {
                if (index == 0) {
                  if (!this.nodes[this.nodes.length - 1].isFixed) {
                    this.nodes.splice(this.nodes.length - 1, 1);
                  }
                } else {
                  if (!this.nodes[index - 1].isFixed) {
                    this.nodes.splice(index - 1, 1);
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        } //---------------------------------------------------
        //  Inject a node
        //  =============
        //  Create a new node between two existing nodes
        //---------------------------------------------------

      }, {
        key: "injectNode",
        value: function injectNode() {
          switch (this.injectionMode) {
            case "RANDOM":
              this.injectRandomNode();
              break;

            case "CURVATURE":
              this.injectNodeByCurvature();
              break;
          }
        } // Inject a new node in a random location, if there is space for it

      }, {
        key: "injectRandomNode",
        value: function injectRandomNode() {
          // Choose two connected nodes at random
          var index = parseInt(this.p5.random(1, this.nodes.length));
          var connectedNodes = this.getConnectedNodes(index);

          if (connectedNodes.previousNode != undefined && connectedNodes.previousNode instanceof Node && connectedNodes.nextNode != undefined && connectedNodes.nextNode instanceof Node && this.nodes[index].distance(connectedNodes.previousNode) > this.settings.MinDistance) {
            // Create a new node in the middle
            var midpointNode = this.getMidpointNode(this.nodes[index], connectedNodes.previousNode); // midpointNode.y += this.p5.random();
            // Splice new node into array

            this.nodes.splice(index, 0, midpointNode);
          }
        } // Inject new node nodes when curvature is too high
        // - When the angle between connected nodes is too high, remove
        //   the middle node and replace it with two nodes at the respective
        //   midpoints of the previous two lines. This "truncates" or "chamfers"
        //   the pointy node into two flatter nodes.

      }, {
        key: "injectNodeByCurvature",
        value: function injectNodeByCurvature() {
          console.log('test');
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = this.nodes.entries()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  index = _step5$value[0],
                  node = _step5$value[1];

              var connectedNodes = this.getConnectedNodes(index); // Find angle between adjacent nodes

              var a = node.distance(connectedNodes.previousNode);
              var b = node.distance(connectedNodes.nextNode);
              var angle = Math.atan(a / b) * 180 / Math.PI; // If angle is below a certain angle (high curvature), replace the current node with two nodes

              if (angle < 30) {
                console.log(index);
                var previousMidpointNode = this.getMidpointNode(node, connectedNodes.previousNode);
                var nextMidpointNode = this.getMidpointNode(node, connectedNodes.nextNode);
                console.log(previousMidpointNode);
                console.log(nextMidpointNode);
                this.p5.noLoop(); // console.log(previousMidpointNode);
                // console.log(nextMidpointNode);
                // Replace this node with the two new nodes

                if (index == 0) {
                  this.nodes.splice(this.nodes.length - 1, 0, previousMidpointNode);
                  this.nodes.splice(0, 1, nextMidpointNode);
                } else {
                  // console.log(index);
                  // console.log(this.nodes);
                  this.nodes.splice(index, 1, previousMidpointNode, nextMidpointNode); // console.log(this.nodes);
                  // this.p5.noLoop();
                }
              }
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        } //------------------------------------------------------------------
        //  Avoid walls
        //  ===========
        //  Clamp node position to the window to prevent "runaway" growth  
        //------------------------------------------------------------------

      }, {
        key: "avoidWalls",
        value: function avoidWalls(index) {
          this.nodes[index].x = this.p5.constrain(this.nodes[index].x, 0, window.innerWidth);
          this.nodes[index].y = this.p5.constrain(this.nodes[index].y, 0, window.innerHeight);
        } //------------------------------------------------------------
        //  Get connected nodes
        //  ===================
        //  For a given node, find and return the nodes that come 
        //  immediately before and after it.
        //------------------------------------------------------------

      }, {
        key: "getConnectedNodes",
        value: function getConnectedNodes(index) {
          var previousNode, nextNode; // Find previous node, if there is one

          if (index == 0 && this.isClosed) {
            previousNode = this.nodes[this.nodes.length - 1];
          } else if (index >= 1) {
            previousNode = this.nodes[index - 1];
          } // Find next node, if there is one


          if (index == this.nodes.length - 1 && this.isClosed) {
            nextNode = this.nodes[0];
          } else if (index <= this.nodes.length - 1) {
            nextNode = this.nodes[index + 1];
          }

          return {
            previousNode: previousNode,
            nextNode: nextNode
          };
        } //------------------------------------------------------------
        //  Get midpoint node
        //  =================
        //  Create and return a node exactly halfway between the
        //  two provided nodes.
        //------------------------------------------------------------

      }, {
        key: "getMidpointNode",
        value: function getMidpointNode(node1, node2) {
          var fixed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          return new Node(this.p5, (node1.x + node2.x) / 2, (node1.y + node2.y) / 2, fixed, this.settings);
        } //--------------------------------------------
        //  Draw
        //  ====
        //  Draw all nodes and edges to the canvas
        //--------------------------------------------

      }, {
        key: "draw",
        value: function draw() {
          // Set shape fill 
          if (this.fillMode) {
            if (!this.traceMode) {
              if (!this.invertedColors) {
                this.p5.fill(0);
              } else {
                this.p5.fill(255);
              }
            } else {
              if (!this.invertedColors) {
                this.p5.fill(0, 1);
              } else {
                this.p5.fill(255, 1);
              }
            }
          } else {
            this.p5.noFill();
          } // Set stroke color


          if (!this.traceMode) {
            if (!this.invertedColors) {
              this.p5.stroke(0);
            } else {
              this.p5.stroke(255);
            }
          } else {
            if (!this.invertedColors) {
              this.p5.stroke(0, 2);
            } else {
              this.p5.stroke(255, 2);
            }
          } // Begin capturing vertices


          if (!this.debugMode) {
            this.p5.beginShape();
          } // Create vertices or lines (if debug mode)


          for (var i = 0; i < this.nodes.length; i++) {
            if (!this.debugMode) {
              this.p5.vertex(this.nodes[i].x, this.nodes[i].y);
            } else {
              // In debug mode each line has a unique stroke color, which isn't possible with begin/endShape(). Instead we'll use line()
              if (i > 0) {
                if (!this.traceMode) {
                  this.p5.stroke(this.p5.map(i, 0, this.nodes.length - 1, 0, 255, true), 255, 255, 255);
                } else {
                  this.p5.stroke(this.p5.map(i, 0, this.nodes.length - 1, 0, 255, true), 255, 255, 2);
                }

                this.p5.line(this.nodes[i - 1].x, this.nodes[i - 1].y, this.nodes[i].x, this.nodes[i].y);
              }
            }
          } // For closed paths, connect the last and first


          if (this.isClosed) {
            if (!this.debugMode) {
              this.p5.vertex(this.nodes[0].x, this.nodes[0].y);
            } else {
              this.p5.line(this.nodes[this.nodes.length - 1].x, this.nodes[this.nodes.length - 1].y, this.nodes[0].x, this.nodes[0].y);
            }
          } // Stop capturing vertices


          if (!this.debugMode) {
            this.p5.endShape();
          } // Draw all nodes


          if (this.drawNodes) {
            this.p5.noStroke();

            if (!this.invertedColors) {
              this.p5.fill(0);
            } else {
              this.p5.fill(255);
            }

            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              for (var _iterator6 = this.nodes.entries()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                var _step6$value = _slicedToArray(_step6.value, 2),
                    index = _step6$value[0],
                    node = _step6$value[1];

                if (this.debugMode) {
                  this.p5.fill(this.p5.map(index, 0, this.nodes.length - 1, 0, 255, true), 255, 255, 255);
                }

                node.draw();
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                  _iterator6.return();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }
          }
        }
      }]);

      return Path;
    }();

    module.exports = Path;
  }, {
    "./Node": 4,
    "./node_modules/rbush-knn": 8
  }],
  6: [function (require, module, exports) {
    var rbush = require('./node_modules/rbush'),
        knn = require('./node_modules/rbush-knn'),
        Defaults = require('./Defaults');
    /*
    =============================================================================
      World class
    
      A World manages a set of Paths and provides some global control
      mechanisms, such as pausing the simulation.
    =============================================================================
    */


    var World =
    /*#__PURE__*/
    function () {
      function World(p5) {
        var paths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Defaults;

        _classCallCheck(this, World);

        this.p5 = p5;
        this.paths = paths;
        this.paused = false;
        this.settings = settings;
        this.traceMode = this.settings.TraceMode;
        this.drawNodes = this.settings.DrawNodes;
        this.debugMode = this.settings.DebugMode;
        this.invertedColors = this.settings.InvertedColors;
        this.fillMode = this.settings.FillMode;
        this.useBrownianMotion = this.settings.UseBrownianMotion;
        this.tree = rbush(9, ['.x', '.y', '.x', '.y']); // use custom accessor strings per https://github.com/mourner/rbush#data-format

        this.buildTree();
      } // Run a single tick for all paths -----------------


      _createClass(World, [{
        key: "iterate",
        value: function iterate() {
          this.buildTree();

          if (this.paths != undefined && this.paths instanceof Array && this.paths.length > 0 && !this.paused) {
            var _iteratorNormalCompletion7 = true;
            var _didIteratorError7 = false;
            var _iteratorError7 = undefined;

            try {
              for (var _iterator7 = this.paths[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                var path = _step7.value;
                path.iterate(this.tree);
              }
            } catch (err) {
              _didIteratorError7 = true;
              _iteratorError7 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                  _iterator7.return();
                }
              } finally {
                if (_didIteratorError7) {
                  throw _iteratorError7;
                }
              }
            }
          }
        } // Draw all paths ----------------------------------

      }, {
        key: "draw",
        value: function draw() {
          if (!this.paused) {
            if (!this.traceMode) {
              this.drawBackground();
            }

            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
              for (var _iterator8 = this.paths[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var path = _step8.value;
                path.draw();
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          }
        } // Draw the background -----------------------------

      }, {
        key: "drawBackground",
        value: function drawBackground() {
          if (!this.invertedColors) {
            this.p5.background(255);
          } else {
            this.p5.background(0);
          }
        } // Build an R-tree spatial index with all paths ----

      }, {
        key: "buildTree",
        value: function buildTree() {
          this.tree.clear();
          var _iteratorNormalCompletion9 = true;
          var _didIteratorError9 = false;
          var _iteratorError9 = undefined;

          try {
            for (var _iterator9 = this.paths[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
              var path = _step9.value;
              this.tree.load(path.nodes);
            }
          } catch (err) {
            _didIteratorError9 = true;
            _iteratorError9 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
                _iterator9.return();
              }
            } finally {
              if (_didIteratorError9) {
                throw _iteratorError9;
              }
            }
          }
        } // Add a new path to the world ---------------------

      }, {
        key: "addPath",
        value: function addPath(path) {
          // Cascade all current settings to new path
          path.drawNodes = this.drawNodes;
          path.traceMode = this.traceMode;
          path.debugMode = this.debugMode;
          path.invertedColors = this.invertedColors;
          path.fillMode = this.fillMode;
          path.useBrownianMotion = this.useBrownianMotion;
          this.paths.push(path);
        } // Remove all paths from the world -----------------

      }, {
        key: "clearPaths",
        value: function clearPaths() {
          this.paths = [];
        } // Pause the simulation ----------------------------

      }, {
        key: "pause",
        value: function pause() {
          this.paused = true;
        } // Unpause the simulation --------------------------

      }, {
        key: "unpause",
        value: function unpause() {
          this.paused = false;
        } // Getters -----------------------------------------

      }, {
        key: "getDrawNodes",
        value: function getDrawNodes() {
          return this.drawNodes;
        }
      }, {
        key: "getTraceMode",
        value: function getTraceMode() {
          return this.traceMode;
        }
      }, {
        key: "getInvertedColors",
        value: function getInvertedColors() {
          return this.invertedColors;
        }
      }, {
        key: "getDebugMode",
        value: function getDebugMode() {
          return this.debugMode;
        }
      }, {
        key: "getFillMode",
        value: function getFillMode() {
          return this.fillMode;
        } // Setters -----------------------------------------

      }, {
        key: "setDrawNodes",
        value: function setDrawNodes(state) {
          var _iteratorNormalCompletion10 = true;
          var _didIteratorError10 = false;
          var _iteratorError10 = undefined;

          try {
            for (var _iterator10 = this.paths[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
              var path = _step10.value;
              path.drawNodes = state;
            }
          } catch (err) {
            _didIteratorError10 = true;
            _iteratorError10 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
                _iterator10.return();
              }
            } finally {
              if (_didIteratorError10) {
                throw _iteratorError10;
              }
            }
          }

          this.drawNodes = state;
        }
      }, {
        key: "setTraceMode",
        value: function setTraceMode(state) {
          var _iteratorNormalCompletion11 = true;
          var _didIteratorError11 = false;
          var _iteratorError11 = undefined;

          try {
            for (var _iterator11 = this.paths[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
              var path = _step11.value;
              path.traceMode = state;
            }
          } catch (err) {
            _didIteratorError11 = true;
            _iteratorError11 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
                _iterator11.return();
              }
            } finally {
              if (_didIteratorError11) {
                throw _iteratorError11;
              }
            }
          }

          this.traceMode = state;
        }
      }, {
        key: "setInvertedColors",
        value: function setInvertedColors(state) {
          var _iteratorNormalCompletion12 = true;
          var _didIteratorError12 = false;
          var _iteratorError12 = undefined;

          try {
            for (var _iterator12 = this.paths[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
              var path = _step12.value;
              path.invertedColors = state;
            }
          } catch (err) {
            _didIteratorError12 = true;
            _iteratorError12 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
                _iterator12.return();
              }
            } finally {
              if (_didIteratorError12) {
                throw _iteratorError12;
              }
            }
          }

          this.invertedColors = state;
        }
      }, {
        key: "setDebugMode",
        value: function setDebugMode(state) {
          var _iteratorNormalCompletion13 = true;
          var _didIteratorError13 = false;
          var _iteratorError13 = undefined;

          try {
            for (var _iterator13 = this.paths[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
              var path = _step13.value;
              path.debugMode = state;
            }
          } catch (err) {
            _didIteratorError13 = true;
            _iteratorError13 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
                _iterator13.return();
              }
            } finally {
              if (_didIteratorError13) {
                throw _iteratorError13;
              }
            }
          }

          this.debugMode = state;
        }
      }, {
        key: "setFillMode",
        value: function setFillMode(state) {
          var _iteratorNormalCompletion14 = true;
          var _didIteratorError14 = false;
          var _iteratorError14 = undefined;

          try {
            for (var _iterator14 = this.paths[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
              var path = _step14.value;
              path.fillMode = state;
            }
          } catch (err) {
            _didIteratorError14 = true;
            _iteratorError14 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
                _iterator14.return();
              }
            } finally {
              if (_didIteratorError14) {
                throw _iteratorError14;
              }
            }
          }

          this.fillMode = state;
        } // Toggles ----------------------------------

      }, {
        key: "toggleDrawNodes",
        value: function toggleDrawNodes() {
          this.setDrawNodes(!this.getDrawNodes());
        }
      }, {
        key: "toggleTraceMode",
        value: function toggleTraceMode() {
          this.setTraceMode(!this.getTraceMode());
        }
      }, {
        key: "toggleInvertedColors",
        value: function toggleInvertedColors() {
          this.setInvertedColors(!this.getInvertedColors());
        }
      }, {
        key: "toggleDebugMode",
        value: function toggleDebugMode() {
          this.setDebugMode(!this.getDebugMode());
        }
      }, {
        key: "toggleFillMode",
        value: function toggleFillMode() {
          this.setFillMode(!this.getFillMode());
        }
      }]);

      return World;
    }();

    module.exports = World;
  }, {
    "./Defaults": 3,
    "./node_modules/rbush": 9,
    "./node_modules/rbush-knn": 8
  }],
  7: [function (require, module, exports) {
    (function (global, factory) {
      _typeof(exports) === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.quickselect = factory();
    })(this, function () {
      'use strict';

      function quickselect(arr, k, left, right, compare) {
        quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
      }

      function quickselectStep(arr, k, left, right, compare) {
        while (right > left) {
          if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;
          swap(arr, left, k);
          if (compare(arr[right], t) > 0) swap(arr, left, right);

          while (i < j) {
            swap(arr, i, j);
            i++;
            j--;

            while (compare(arr[i], t) < 0) {
              i++;
            }

            while (compare(arr[j], t) > 0) {
              j--;
            }
          }

          if (compare(arr[left], t) === 0) swap(arr, left, j);else {
            j++;
            swap(arr, j, right);
          }
          if (j <= k) left = j + 1;
          if (k <= j) right = j - 1;
        }
      }

      function swap(arr, i, j) {
        var tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }

      function defaultCompare(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }

      return quickselect;
    });
  }, {}],
  8: [function (require, module, exports) {
    'use strict';

    var Queue = require('tinyqueue');

    module.exports = knn;
    module.exports.default = knn;

    function knn(tree, x, y, n, predicate, maxDistance) {
      var node = tree.data,
          result = [],
          toBBox = tree.toBBox,
          i,
          child,
          dist,
          candidate;
      var queue = new Queue(null, compareDist);

      while (node) {
        for (i = 0; i < node.children.length; i++) {
          child = node.children[i];
          dist = boxDist(x, y, node.leaf ? toBBox(child) : child);

          if (!maxDistance || dist <= maxDistance) {
            queue.push({
              node: child,
              isItem: node.leaf,
              dist: dist
            });
          }
        }

        while (queue.length && queue.peek().isItem) {
          candidate = queue.pop().node;
          if (!predicate || predicate(candidate)) result.push(candidate);
          if (n && result.length === n) return result;
        }

        node = queue.pop();
        if (node) node = node.node;
      }

      return result;
    }

    function compareDist(a, b) {
      return a.dist - b.dist;
    }

    function boxDist(x, y, box) {
      var dx = axisDist(x, box.minX, box.maxX),
          dy = axisDist(y, box.minY, box.maxY);
      return dx * dx + dy * dy;
    }

    function axisDist(k, min, max) {
      return k < min ? min - k : k <= max ? 0 : k - max;
    }
  }, {
    "tinyqueue": 10
  }],
  9: [function (require, module, exports) {
    'use strict';

    module.exports = rbush;
    module.exports.default = rbush;

    var quickselect = require('quickselect');

    function rbush(maxEntries, format) {
      if (!(this instanceof rbush)) return new rbush(maxEntries, format); // max entries in a node is 9 by default; min node fill is 40% for best performance

      this._maxEntries = Math.max(4, maxEntries || 9);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

      if (format) {
        this._initFormat(format);
      }

      this.clear();
    }

    rbush.prototype = {
      all: function all() {
        return this._all(this.data, []);
      },
      search: function search(bbox) {
        var node = this.data,
            result = [],
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return result;
        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
              if (node.leaf) result.push(child);else if (contains(bbox, childBBox)) this._all(child, result);else nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return result;
      },
      collides: function collides(bbox) {
        var node = this.data,
            toBBox = this.toBBox;
        if (!intersects(bbox, node)) return false;
        var nodesToSearch = [],
            i,
            len,
            child,
            childBBox;

        while (node) {
          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) return true;
              nodesToSearch.push(child);
            }
          }

          node = nodesToSearch.pop();
        }

        return false;
      },
      load: function load(data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
          for (var i = 0, len = data.length; i < len; i++) {
            this.insert(data[i]);
          }

          return this;
        } // recursively build the tree with the given data from scratch using OMT algorithm


        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
          // save as is if tree is empty
          this.data = node;
        } else if (this.data.height === node.height) {
          // split root if trees have the same height
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            // swap trees if inserted one is bigger
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          } // insert the small tree into the large tree at appropriate level


          this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
      },
      insert: function insert(item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
      },
      clear: function clear() {
        this.data = createNode([]);
        return this;
      },
      remove: function remove(item, equalsFn) {
        if (!item) return this;
        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i,
            parent,
            index,
            goingUp; // depth-first iterative tree traversal

        while (node || path.length) {
          if (!node) {
            // go up
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }

          if (node.leaf) {
            // check current node
            index = findItem(item, node.children, equalsFn);

            if (index !== -1) {
              // item found, remove the item and condense tree upwards
              node.children.splice(index, 1);
              path.push(node);

              this._condense(path);

              return this;
            }
          }

          if (!goingUp && !node.leaf && contains(node, bbox)) {
            // go down
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            // go right
            i++;
            node = parent.children[i];
            goingUp = false;
          } else node = null; // nothing found

        }

        return this;
      },
      toBBox: function toBBox(item) {
        return item;
      },
      compareMinX: compareNodeMinX,
      compareMinY: compareNodeMinY,
      toJSON: function toJSON() {
        return this.data;
      },
      fromJSON: function fromJSON(data) {
        this.data = data;
        return this;
      },
      _all: function _all(node, result) {
        var nodesToSearch = [];

        while (node) {
          if (node.leaf) result.push.apply(result, node.children);else nodesToSearch.push.apply(nodesToSearch, node.children);
          node = nodesToSearch.pop();
        }

        return result;
      },
      _build: function _build(items, left, right, height) {
        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
          // reached leaf level; return leaf
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }

        if (!height) {
          // target height of the bulk-loaded tree
          height = Math.ceil(Math.log(N) / Math.log(M)); // target number of root entries to maximize storage utilization

          M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height; // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i,
            j,
            right2,
            right3;
        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {
          right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);

          for (j = i; j <= right2; j += N2) {
            right3 = Math.min(j + N2 - 1, right2); // pack each entry recursively

            node.children.push(this._build(items, j, right3, height - 1));
          }
        }

        calcBBox(node, this.toBBox);
        return node;
      },
      _chooseSubtree: function _chooseSubtree(bbox, node, level, path) {
        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level) break;
          minArea = minEnlargement = Infinity;

          for (i = 0, len = node.children.length; i < len; i++) {
            child = node.children[i];
            area = bboxArea(child);
            enlargement = enlargedArea(bbox, child) - area; // choose entry with the least area enlargement

            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              // otherwise choose one with the smallest area
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }

          node = targetNode || node.children[0];
        }

        return node;
      },
      _insert: function _insert(item, level, isNode) {
        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = []; // find the best node for accommodating the item, saving all nodes along the path too

        var node = this._chooseSubtree(bbox, this.data, level, insertPath); // put the item into the node


        node.children.push(item);
        extend(node, bbox); // split on node overflow; propagate upwards if necessary

        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);

            level--;
          } else break;
        } // adjust bboxes along the insertion path


        this._adjustParentBBoxes(bbox, insertPath, level);
      },
      // split overflowed node into two
      _split: function _split(insertPath, level) {
        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level) insertPath[level - 1].children.push(newNode);else this._splitRoot(node, newNode);
      },
      _splitRoot: function _splitRoot(node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      },
      _chooseSplitIndex: function _chooseSplitIndex(node, m, M) {
        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;
        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
          bbox1 = distBBox(node, 0, i, this.toBBox);
          bbox2 = distBBox(node, i, M, this.toBBox);
          overlap = intersectionArea(bbox1, bbox2);
          area = bboxArea(bbox1) + bboxArea(bbox2); // choose distribution with minimum overlap

          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            // otherwise choose distribution with minimum area
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }

        return index;
      },
      // sorts node children by the best axis for split
      _chooseSplitAxis: function _chooseSplitAxis(node, m, M) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY); // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY


        if (xMargin < yMargin) node.children.sort(compareMinX);
      },
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin: function _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i,
            child;

        for (i = m; i < M - m; i++) {
          child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
          child = node.children[i];
          extend(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }

        return margin;
      },
      _adjustParentBBoxes: function _adjustParentBBoxes(bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
        }
      },
      _condense: function _condense(path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else this.clear();
          } else calcBBox(path[i], this.toBBox);
        }
      },
      _initFormat: function _initFormat(format) {
        // data format (minX, minY, maxX, maxY accessors)
        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls
        var compareArr = ['return a', ' - b', ';'];
        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));
        this.toBBox = new Function('a', 'return {minX: a' + format[0] + ', minY: a' + format[1] + ', maxX: a' + format[2] + ', maxY: a' + format[3] + '};');
      }
    };

    function findItem(item, items, equalsFn) {
      if (!equalsFn) return items.indexOf(item);

      for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
      }

      return -1;
    } // calculate node's bbox from bboxes of its children


    function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
    } // min bounding rectangle of node children from k to p-1


    function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) destNode = createNode(null);
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
    }

    function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
    }

    function compareNodeMinX(a, b) {
      return a.minX - b.minX;
    }

    function compareNodeMinY(a, b) {
      return a.minY - b.minY;
    }

    function bboxArea(a) {
      return (a.maxX - a.minX) * (a.maxY - a.minY);
    }

    function bboxMargin(a) {
      return a.maxX - a.minX + (a.maxY - a.minY);
    }

    function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
    }

    function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX),
          minY = Math.max(a.minY, b.minY),
          maxX = Math.min(a.maxX, b.maxX),
          maxY = Math.min(a.maxY, b.maxY);
      return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
    }

    function contains(a, b) {
      return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
    }

    function intersects(a, b) {
      return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
    }

    function createNode(children) {
      return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
      };
    } // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
    // combines selection algorithm with binary divide & conquer approach


    function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right],
          mid;

      while (stack.length) {
        right = stack.pop();
        left = stack.pop();
        if (right - left <= n) continue;
        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);
        stack.push(left, mid, mid, right);
      }
    }
  }, {
    "quickselect": 7
  }],
  10: [function (require, module, exports) {
    'use strict';

    module.exports = TinyQueue;
    module.exports.default = TinyQueue;

    function TinyQueue(data, compare) {
      if (!(this instanceof TinyQueue)) return new TinyQueue(data, compare);
      this.data = data || [];
      this.length = this.data.length;
      this.compare = compare || defaultCompare;

      if (this.length > 0) {
        for (var i = (this.length >> 1) - 1; i >= 0; i--) {
          this._down(i);
        }
      }
    }

    function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }

    TinyQueue.prototype = {
      push: function push(item) {
        this.data.push(item);
        this.length++;

        this._up(this.length - 1);
      },
      pop: function pop() {
        if (this.length === 0) return undefined;
        var top = this.data[0];
        this.length--;

        if (this.length > 0) {
          this.data[0] = this.data[this.length];

          this._down(0);
        }

        this.data.pop();
        return top;
      },
      peek: function peek() {
        return this.data[0];
      },
      _up: function _up(pos) {
        var data = this.data;
        var compare = this.compare;
        var item = data[pos];

        while (pos > 0) {
          var parent = pos - 1 >> 1;
          var current = data[parent];
          if (compare(item, current) >= 0) break;
          data[pos] = current;
          pos = parent;
        }

        data[pos] = item;
      },
      _down: function _down(pos) {
        var data = this.data;
        var compare = this.compare;
        var halfLength = this.length >> 1;
        var item = data[pos];

        while (pos < halfLength) {
          var left = (pos << 1) + 1;
          var right = left + 1;
          var best = data[left];

          if (right < this.length && compare(data[right], best) < 0) {
            left = right;
            best = data[right];
          }

          if (compare(best, item) >= 0) break;
          data[pos] = best;
          pos = left;
        }

        data[pos] = item;
      }
    };
  }, {}],
  11: [function (require, module, exports) {
    ;

    (function inject(clean, precision, undef) {
      var isArray = function isArray(a) {
        return Object.prototype.toString.call(a) === "[object Array]";
      };

      var defined = function defined(a) {
        return a !== undef;
      };

      function Vec2(x, y) {
        if (!(this instanceof Vec2)) {
          return new Vec2(x, y);
        }

        if (isArray(x)) {
          y = x[1];
          x = x[0];
        } else if ('object' === _typeof(x) && x) {
          y = x.y;
          x = x.x;
        }

        this.x = Vec2.clean(x || 0);
        this.y = Vec2.clean(y || 0);
      }

      Vec2.prototype = {
        change: function change(fn) {
          if (typeof fn === 'function') {
            if (this.observers) {
              this.observers.push(fn);
            } else {
              this.observers = [fn];
            }
          } else if (this.observers && this.observers.length) {
            for (var i = this.observers.length - 1; i >= 0; i--) {
              this.observers[i](this, fn);
            }
          }

          return this;
        },
        ignore: function ignore(fn) {
          if (this.observers) {
            if (!fn) {
              this.observers = [];
            } else {
              var o = this.observers,
                  l = o.length;

              while (l--) {
                o[l] === fn && o.splice(l, 1);
              }
            }
          }

          return this;
        },
        // set x and y
        set: function set(x, y, notify) {
          if ('number' != typeof x) {
            notify = y;
            y = x.y;
            x = x.x;
          }

          if (this.x === x && this.y === y) {
            return this;
          }

          var orig = null;

          if (notify !== false && this.observers && this.observers.length) {
            orig = this.clone();
          }

          this.x = Vec2.clean(x);
          this.y = Vec2.clean(y);

          if (notify !== false) {
            return this.change(orig);
          }
        },
        // reset x and y to zero
        zero: function zero() {
          return this.set(0, 0);
        },
        // return a new vector with the same component values
        // as this one
        clone: function clone() {
          return new this.constructor(this.x, this.y);
        },
        // negate the values of this vector
        negate: function negate(returnNew) {
          if (returnNew) {
            return new this.constructor(-this.x, -this.y);
          } else {
            return this.set(-this.x, -this.y);
          }
        },
        // Add the incoming `vec2` vector to this vector
        add: function add(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          }

          x += this.x;
          y += this.y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            // Return a new vector if `returnNew` is truthy
            return new this.constructor(x, y);
          }
        },
        // Subtract the incoming `vec2` from this vector
        subtract: function subtract(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          }

          x = this.x - x;
          y = this.y - y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            // Return a new vector if `returnNew` is truthy
            return new this.constructor(x, y);
          }
        },
        // Multiply this vector by the incoming `vec2`
        multiply: function multiply(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          } else if (typeof y != 'number') {
            returnNew = y;
            y = x;
          }

          x *= this.x;
          y *= this.y;

          if (!returnNew) {
            return this.set(x, y);
          } else {
            return new this.constructor(x, y);
          }
        },
        // Rotate this vector. Accepts a `Rotation` or angle in radians.
        //
        // Passing a truthy `inverse` will cause the rotation to
        // be reversed.
        //
        // If `returnNew` is truthy, a new
        // `Vec2` will be created with the values resulting from
        // the rotation. Otherwise the rotation will be applied
        // to this vector directly, and this vector will be returned.
        rotate: function rotate(r, inverse, returnNew) {
          var x = this.x,
              y = this.y,
              cos = Math.cos(r),
              sin = Math.sin(r),
              rx,
              ry;
          inverse = inverse ? -1 : 1;
          rx = cos * x - inverse * sin * y;
          ry = inverse * sin * x + cos * y;

          if (returnNew) {
            return new this.constructor(rx, ry);
          } else {
            return this.set(rx, ry);
          }
        },
        // Calculate the length of this vector
        length: function length() {
          var x = this.x,
              y = this.y;
          return Math.sqrt(x * x + y * y);
        },
        // Get the length squared. For performance, use this instead of `Vec2#length` (if possible).
        lengthSquared: function lengthSquared() {
          var x = this.x,
              y = this.y;
          return x * x + y * y;
        },
        // Return the distance betwen this `Vec2` and the incoming vec2 vector
        // and return a scalar
        distance: function distance(vec2) {
          var x = this.x - vec2.x;
          var y = this.y - vec2.y;
          return Math.sqrt(x * x + y * y);
        },
        // Given Array of Vec2, find closest to this Vec2.
        nearest: function nearest(others) {
          var shortestDistance = Number.MAX_VALUE,
              nearest = null,
              currentDistance;

          for (var i = others.length - 1; i >= 0; i--) {
            currentDistance = this.distance(others[i]);

            if (currentDistance <= shortestDistance) {
              shortestDistance = currentDistance;
              nearest = others[i];
            }
          }

          return nearest;
        },
        // Convert this vector into a unit vector.
        // Returns the length.
        normalize: function normalize(returnNew) {
          var length = this.length(); // Collect a ratio to shrink the x and y coords

          var invertedLength = length < Number.MIN_VALUE ? 0 : 1 / length;

          if (!returnNew) {
            // Convert the coords to be greater than zero
            // but smaller than or equal to 1.0
            return this.set(this.x * invertedLength, this.y * invertedLength);
          } else {
            return new this.constructor(this.x * invertedLength, this.y * invertedLength);
          }
        },
        // Determine if another `Vec2`'s components match this one's
        // also accepts 2 scalars
        equal: function equal(v, w) {
          if (typeof v != 'number') {
            if (isArray(v)) {
              w = v[1];
              v = v[0];
            } else {
              w = v.y;
              v = v.x;
            }
          }

          return Vec2.clean(v) === this.x && Vec2.clean(w) === this.y;
        },
        // Return a new `Vec2` that contains the absolute value of
        // each of this vector's parts
        abs: function abs(returnNew) {
          var x = Math.abs(this.x),
              y = Math.abs(this.y);

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Return a new `Vec2` consisting of the smallest values
        // from this vector and the incoming
        //
        // When returnNew is truthy, a new `Vec2` will be returned
        // otherwise the minimum values in either this or `v` will
        // be applied to this vector.
        min: function min(v, returnNew) {
          var tx = this.x,
              ty = this.y,
              vx = v.x,
              vy = v.y,
              x = tx < vx ? tx : vx,
              y = ty < vy ? ty : vy;

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Return a new `Vec2` consisting of the largest values
        // from this vector and the incoming
        //
        // When returnNew is truthy, a new `Vec2` will be returned
        // otherwise the minimum values in either this or `v` will
        // be applied to this vector.
        max: function max(v, returnNew) {
          var tx = this.x,
              ty = this.y,
              vx = v.x,
              vy = v.y,
              x = tx > vx ? tx : vx,
              y = ty > vy ? ty : vy;

          if (returnNew) {
            return new this.constructor(x, y);
          } else {
            return this.set(x, y);
          }
        },
        // Clamp values into a range.
        // If this vector's values are lower than the `low`'s
        // values, then raise them.  If they are higher than
        // `high`'s then lower them.
        //
        // Passing returnNew as true will cause a new Vec2 to be
        // returned.  Otherwise, this vector's values will be clamped
        clamp: function clamp(low, high, returnNew) {
          var ret = this.min(high, true).max(low);

          if (returnNew) {
            return ret;
          } else {
            return this.set(ret.x, ret.y);
          }
        },
        // Perform linear interpolation between two vectors
        // amount is a decimal between 0 and 1
        lerp: function lerp(vec, amount, returnNew) {
          return this.add(vec.subtract(this, true).multiply(amount), returnNew);
        },
        // Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
        skew: function skew(returnNew) {
          if (!returnNew) {
            return this.set(-this.y, this.x);
          } else {
            return new this.constructor(-this.y, this.x);
          }
        },
        // calculate the dot product between
        // this vector and the incoming
        dot: function dot(b) {
          return Vec2.clean(this.x * b.x + b.y * this.y);
        },
        // calculate the perpendicular dot product between
        // this vector and the incoming
        perpDot: function perpDot(b) {
          return Vec2.clean(this.x * b.y - this.y * b.x);
        },
        // Determine the angle between two vec2s
        angleTo: function angleTo(vec) {
          return Math.atan2(this.perpDot(vec), this.dot(vec));
        },
        // Divide this vector's components by a scalar
        divide: function divide(x, y, returnNew) {
          if (typeof x != 'number') {
            returnNew = y;

            if (isArray(x)) {
              y = x[1];
              x = x[0];
            } else {
              y = x.y;
              x = x.x;
            }
          } else if (typeof y != 'number') {
            returnNew = y;
            y = x;
          }

          if (x === 0 || y === 0) {
            throw new Error('division by zero');
          }

          if (isNaN(x) || isNaN(y)) {
            throw new Error('NaN detected');
          }

          if (returnNew) {
            return new this.constructor(this.x / x, this.y / y);
          }

          return this.set(this.x / x, this.y / y);
        },
        isPointOnLine: function isPointOnLine(start, end) {
          return (start.y - this.y) * (start.x - end.x) === (start.y - end.y) * (start.x - this.x);
        },
        toArray: function toArray() {
          return [this.x, this.y];
        },
        fromArray: function fromArray(array) {
          return this.set(array[0], array[1]);
        },
        toJSON: function toJSON() {
          return {
            x: this.x,
            y: this.y
          };
        },
        toString: function toString() {
          return '(' + this.x + ', ' + this.y + ')';
        },
        constructor: Vec2
      };

      Vec2.fromArray = function (array, ctor) {
        return new (ctor || Vec2)(array[0], array[1]);
      }; // Floating point stability


      Vec2.precision = precision || 8;
      var p = Math.pow(10, Vec2.precision);

      Vec2.clean = clean || function (val) {
        if (isNaN(val)) {
          throw new Error('NaN detected');
        }

        if (!isFinite(val)) {
          throw new Error('Infinity detected');
        }

        if (Math.round(val) === val) {
          return val;
        }

        return Math.round(val * p) / p;
      };

      Vec2.inject = inject;

      if (!clean) {
        Vec2.fast = inject(function (k) {
          return k;
        }); // Expose, but also allow creating a fresh Vec2 subclass.

        if (typeof module !== 'undefined' && _typeof(module.exports) == 'object') {
          module.exports = Vec2;
        } else {
          window.Vec2 = window.Vec2 || Vec2;
        }
      }

      return Vec2;
    })();
  }, {}]
}, {}, [2]);